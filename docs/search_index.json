[
["index.html", "실무 빅데이터 분석을 위한 SQL과 R의 활용 CAMP 머리말", " 실무 빅데이터 분석을 위한 SQL과 R의 활용 CAMP 박찬엽 2017-04-06 머리말 이 책은 패스트캠퍼스의 데이터 사이언스 캠프 코스의 실무 빅데이터 분석을 위한 SQL과 R의 활용 CAMP의 수업용으로 제작되었습니다. 수업에 대해 더 자세히 알고 싶으신 분은 강사 인터뷰를 참고하세요. 책은 1. R의 IDE로 사실상 표준인 RStudio에 사용하기 좋은 기능 소개 2. 대부분의 에러 문제를 해결할 수 있는 기초 자료형에 대한 이해 3. 단순 반복 업무를 위한 for문과 apply류 맛보기 4. 데이터 원본/의존성의 개념과 SQL 문법 익히기 5. tidy data 개념과 dplyr+tidyr로 데이터 다루기 6. 보고용 차트를 위한 ggplot2 사용하기 7. 정기 보고서 자동 작성을 위해 knitr로 문서화하고 스케줄러로 자동화하기 8. shiny 패키지를 활용한 인터렉티프 웹 만들기 로 구성되어 있습니다. 많은 부분 rstudio-IDE-cheatsheet, R for Data Science, R Programming for Data Science, ggplot2-book, shiny-tutorial, Microsoft’s DAT204x, datacamp, programiz 등 을 참고하였습니다. 데이터 분석은 많은 단계들과 업무들로 나누어져 있습니다. 개인적으로 1. 데이터 확보 2. 데이터 정제 3. 분석 4. 시각화의 단계를 거친다고 생각합니다. 데이터란 사내에서 관리하고 있는 내부 데이터와 외부 인터넷에 공개되어 있는 데이터로 구분할 수 있습니다. 이런 데이터들 중 분석과 업무 목적에 맞는 데이터를 찾고, 활용하기 위에 확보하는 과정이 1단계 입니다. 분석 방법과 내용에 따라 확보된 데이터를 정리하거나 고쳐야 하는 일도 있습니다. 2 단계는 그것을 뜻합니다. 3 단계인 분석은 다양한 통계적 방법들을 통해 분석 목적을 이루는 것입니다. 4단계는 이렇게 이루어낸 결과물을 다른 사람에게 전달하기 위해 필요합니다. 이 책은 그 중 2단계인 정제와 4단계인 시각화에 초점이 맞춰져 있습니다. 계속 업데이트되므로 정보 챕터 하단에 업데이트 날짜를 확인하세요. 저작물 라이선스로 크리에이티브 커먼즈 라이선스 4.0(저작자 표시-비영리-변경 금지(BY-NC-ND))를 따릅니다. "],
["-.html", "시작하기 전에 0.1 데이터를 다루는 것 0.2 준비된 데이터 0.3 R과 Rstudio 0.4 git과 github 0.5 사용할 데이터베이스 0.6 환경 통일을 위한 도구 도커 0.7 정보", " 시작하기 전에 수업에서 사용하는 자료와 기반하는 생각들을 작성하고자 합니다. 0.1 데이터를 다루는 것 데이터 과학을 진행하는데에는 아래의 과정을 따릅니다. 공부를 위해 작성하는 자료니 만큼 자료를 생산하는 모든 코드는 숨기지 않고 같이 출력하겠습니다. library(&quot;visNetwork&quot;) nodes &lt;- data.frame(id = 1:7,label=c(&quot;1. 데이터 확보&quot;,&quot;2. 데이터 정제&quot;, &quot;3. 분석&quot;,&quot;데이터 핸들링&quot;,&quot;분석&quot;,&quot;결과 검증&quot;,&quot;4. 시각화&quot;), shape=&quot;box&quot;, font.size=25) edges &lt;- data.frame(from = c(1,2,3,4,5,3,6), to = c(2,3,7,5,6,4,4), dashes = c(F,F,F,F,F,T,F), length=100) visNetwork(nodes, edges, width = &quot;100%&quot;) %&gt;% visEdges(arrows =list(to = list(enabled = TRUE, scaleFactor = 1))) %&gt;% visLayout(randomSeed = -0.9261698*10000) 위 표는 해들리 위컴의 R for Data Science에 소개에 작성된 표이기도 합니다. 각각 Import, Tidy, Transform, Visualise, Model, Communicate라고 되어 있는 것을 제 상황에 맞게 각색하였습니다. 데이터 확보는 분석 목적에 맞는 데이터를 확보하는 것입니다. 보통 기업인의 입장에서 기업 내부에서 생산, 관리되고 있는 데이터, 외부에서 찾아야 하는 데이터, 없기 때문에 실험등을 통해 생산해야 하는 데이터 정도로 데이터를 나눌 수 있습니다. 이 때 내부 데이터를 사용하기 위해서는 두 가지 진입장벽이 있는데, 정책적인 접근 권한과 데이터를 다룰 줄 아는 능력입니다. 이 후 과정에서 데이터를 다루고, 그것으로 통계적 분석을 거쳐 필요한 결과물을 만드는 것에서 가장 보편적인 도구는 엑셀입니다. 데부분은 엑셀을 잘 사용하는 것으로 해결할 수 있습니다. 하지만 데이터가 커지고, 통계적 분석에 대한 수요가 높아지면서 R에 대한 관심으로 이어지고 있는 상황입니다. 데이터 정제는 해들리 위컴이 이야기한 Tidy data를 만드는 과정에 해당합니다. 이것을 위해서 Tidy data에 대해서 이야기 해야 하는데 그건 6장에서 다루려고 합니다. 간단하게는 컴퓨터에게 일을 시키기 좋은 상태로 데이터를 정리하는 것을 뜻합니다. 시간이 많이 드는 과정입니다. 분석은 데이터 핸들링, 분석, 결과 검증의 사이클을 따라 반복합니다. EDA나 데이터 이해를 위한 시각화 등이 이루어지고, 분석을 진행하며 얻는 결과물들을 만드는 과정이 진행됩니다. 이 때 개발에서 재현성의 개념을 가져오면 일을 좀 수월하게 할 수 있습니다. 여기서 말하는 재현성이란 연구 재현성보다는 실행 재현성을 뜻합니다. 실행 재현성은 어떤 결과물을 만드는 작업을 실행했을 때 다시 그것을 그대로 실행할 수 있는 것을 뜻합니다. 코드로 분석을 진행하는 것은 실행 재현성과 자동화에 매우 도움이 됩니다. 시각화는 앞서 반복적인 연구를 통해 알게된 사실을 다른 사람들에게 전달하는 과정 전체를 뜻합니다. 본 자료에서는 그래서 차트그리기 뿐만 아니라 Rmd를 활용한 문서화와 shiny를 활용한 앱 또한 시각화의 일부로써 다루고 있습니다. 위 4개 과정을 모두 다룰 줄 알면, 이제 도구를 다룰줄 알게 되는 것입니다. 연구나 분석 능력은 또 별개이지 않나 싶습니다. 이 책을 지속적으로 업데이트해서 연구와 분석, 데이터 과학에 대해 모두 다루는 책이 되기를 희망합니다. 0.2 준비된 데이터 수업을 위해 준비한 데이터는 고위 공직자 재산, 세종기업데이터를 크롤링한 깃헙 저장소, outbrain이 캐글에 공개한 사용자 웹 클릭 데이터 입니다. 웹 클릭 데이터는 특별히 sql로 데이터 핸들링을 하는 것에 대한 경험을 확보하기 위해서 찾아보았으며 전체 데이터는 약 100GB에 달하는 방대한 양입니다. 수업에서 실제로 다루기 보다는 다루어 보실 수 있게 데이터를 준비했습니다. 0.3 R과 Rstudio R은 여기에서 다운로드 할 수 있습니다. RStudio은 R을 사용하기 위한 IDE로 여러 편의성을 제공합니다. 자세한 사용법은 2장에서 소개합니다. 0.4 git과 github git은 코드의 버전관리 도구로 github의 인기에 힘입어 많은 개발자들이 사용하고 있습니다. 코드를 공개해 사용하면 무료이며, 이 책을 호스팅 하는 것처럼 각 아이디의 서브도메인을 무료로 사용할 수 있게 제공해줍니다. 수업에서는 자료 공유의 목적과 다른 사용자의 코드를 사용하는 수준으로 사용을 권장할 예정이며 깊게 공부하고 싶다면 한글자료가 많이 준비되어 있으니 참고하시기 바랍니다. 0.5 사용할 데이터베이스 오픈소스인 mariaDB을 사용하려고 합니다. 사용한 이유는 이 기사가 잘 설명하는 것 같습니다. 기본적으로는 전통적인 RDBMS이면서 많은 사람들이 사용하는 제품이기 때문입니다. 수업에 사용하는 모든 서비스, 패키지 등 일체는 모두 1. 오픈 소스이고 2. 많은 사용자를 확보해서 활발히 발달하고 있으며 3. 참고할 자료가 많은 것을 선택하려고 노력했습니다. 데이터베이스의 설치는 windows, mac을 참고해 주세요. mariaDB와 함께 인터페이스로 설치되는 HeidiSQL은 데이터베이스를 관리하는데 사용하는 GUI 툴입니다. 맥에서는 WINE을 통해서 사용할 수 있다고 하는데, Sequel Pro라는 도구도 있고, 설치를 소개하는 블로그가 있으니 참고하시기 바랍니다. 0.6 환경 통일을 위한 도구 도커 수업에서 다루지는 않지만 설치나 다른 환경 세팅으로 인한 시간 소모를 줄이기 위해서 docker를 사용할 수 있습니다. 수업 데이터가 준비되어 있는 마리아디비 도커 이미지를 준비하고 있습니다. 윈도우에서 하이퍼바이저(pro 버전 등에서 사용가능)가 있지 않은 경우 버추얼박스를 통해서 동작하므로 성능이 떨어질 수 있습니다. 0.7 정보 이 책의 소스는 여기에서 확인하실 수 있으며 아래 주어진 R 패키지(및 종속 패키지)의 버전으로 제작되었습니다. 저작물의 재현을 위해서 필요합니다. package * version date source backports 1.0.5 2017-01-18 CRAN (R 3.3.3) bookdown 0.3 2016-11-28 CRAN (R 3.3.3) codetools 0.2-15 2016-10-05 CRAN (R 3.3.3) devtools 1.12.0 2016-12-05 CRAN (R 3.3.3) digest 0.6.12 2017-01-27 CRAN (R 3.3.3) evaluate 0.10 2016-10-11 CRAN (R 3.3.3) htmltools 0.3.5 2016-03-21 CRAN (R 3.3.3) htmlwidgets 0.8 2016-11-09 CRAN (R 3.3.3) jsonlite 1.3 2017-02-28 CRAN (R 3.3.3) knitr 1.15.1 2016-11-22 CRAN (R 3.3.3) magrittr 1.5 2014-11-22 CRAN (R 3.3.3) memoise 1.0.0 2016-01-29 CRAN (R 3.3.3) Rcpp 0.12.10 2017-03-19 CRAN (R 3.3.3) rmarkdown 1.3 2016-12-21 CRAN (R 3.3.3) rprojroot 1.2 2017-01-16 CRAN (R 3.3.3) stringi 1.1.2 2016-10-01 CRAN (R 3.3.3) stringr 1.2.0 2017-02-18 CRAN (R 3.3.3) visNetwork * 1.0.3 2016-12-22 CRAN (R 3.3.3) withr 1.0.2 2016-06-20 CRAN (R 3.3.3) yaml 2.1.14 2016-11-12 CRAN (R 3.3.3) 이 책은 박찬엽이 Thursday, April 20, 2017 09:39:50 AM UTC에 마지막으로 업데이트 했습니다. "],
["rstudio.html", "1 RStudio에 사용하기 좋은 기능 소개 1.1 RStudio 소개 1.2 구조와 기능들 1.3 프로젝트와 버전관리 1.4 도움말", " 1 RStudio에 사용하기 좋은 기능 소개 첫 수업은 RStudio를, 정확하게는 IDE에서 받을 수 있는 기능적 혜택들을 소개하려고 합니다. 1.1 RStudio 소개 1.1.1 IDE 란 IDE란 _통합 개발 환경_의 영어 줄임말로 텍스트 편집이외에도 디버깅, 컴파일, 배포등 개발의 위한 기능을 통합적으로 제공하는 프로그램을 지칭합니다. R 또한 개발언어의 일종으로 여러 IDE에서 사용할 수 있게 지원하고 있습니다. 1.1.2 Rstudio RStudio는 R을 처음 배우는 사람이 꼭 사용하는 IDE입니다. 다른 IDE에 비해 R 언어에 특화된 UI와 기능을 가지고 있으며 ggplot2, shiny, dplyr, httr 등 다양항 패키지를 왕성하게 만들고 있는 RStudio 팀이 직접 관리를 하기 때문에 문서도 많고, 우리나라 사용자층도 큰 편입니다. 특히 초보자부터 고급 사용자까지 필요한 많은 기능들을 GUI로 제공해 줘서 배울 수록 편리함이 늘어납니다. 1.1.3 다른 IDE 소개 IDE는 메모장 처럼 가벼운 Sublime Text부터 본격적인 Visual Studio까지 다양합니다. 개발자들이 많이 사용하는 IDE를 몇개 소개하겠습니다. Sublime Text는 꽤 오랫동안 사랑받은 텍스트 에디터 형 IDE입니다. 몇 가지 설정을 진행하면 R 코드도 실행하게 만들 수 있어 기존 개발자 분들 중 R을 공부하실 때 사용하는 경우가 종종 있습니다. Atom은 웹기술을 활용해서 어느 컴퓨터에서든 사용할 수 있는 범용성을 가진 IDE입니다. 가장 큰 강점은 plugin 제작이 쉬워서 사용자층이 폭발적으로 늘어나서 최근 많은 개발자들이 사용하고 있습니다. 대부분 웹 개발에 사용되며 오픈소스여서 비용이 발생하지 않는 장점이 있습니다. Vs Code는 Atom의 소스를 사용해서 마이크로소프트에서 수정한 IDE입니다. 여전히 오픈소스이며 큰 기업이 지원하는 만큼 기능 정리를 통한 최적화가 강점입니다. github 연동, 자동 업데이트 등 사용자 편의에 조금 더 중점을 두었습니다. Nuclide도 역시 Atom의 소스를 사용해서 페이스북이 만든 IDE입니다. 역시 오픈소스이며 remote Development를 기본 제공하는 것이 특징입니다. 페이스북 내에서 사용하기 위해 만들어졌다보니 웹개발에 조금더 최적화되어 있습니다. 마이크로 소프트가 레볼루션 R을 인수하면서 R 생태계 흡수를 위해 여러 기능들을 지원하는데요. RTVS이 대표적입니다. Visual Studio는 꽤 오랫동안 개발자들이 사용한 IDE입니다. IDE라는 말이 어울리게 수GB의 용량을 차지하고 매우 많은 기능들을 제공합니다. RTVS는 이런 Visual Studio에서 R을 사용할 수 있게 만든 기능으로 무료로 공개한 Visual Studio 2015 커뮤니티 버전에 설치하여 R의 사용환경을 구성할 수 있습니다. 1.2 구조와 기능들 RStudio는 처음부터 R을 지원하기 때문에 설치 이외의 작업을 할 필요 없고, 사용자층이 많아 사용법을 배우기도 좋고 검색도 쉽게 됩니다. 그래서 IDE를 RStudio로 선정하고 기능에 대해 설명하겠습니다. 여기 설명하는 기능은 RStudio만의 기능이 아니며 다른 IDE도 구성에 따라 같은 기능 혹은 더 나은 기능을 사용할 수 있습니다. 처음 실행하면 전부 4개면(pane)으로 구성되어 있으며 각부의 이름 은 위 그림과 같습니다. source 창은 코드와 그 순서를 저장하는 script를 보여주는 곳입니다. console 창은 R의 엔진과 대화(!)를 할 수 있는 공간합니다. 명령어를 입력하면, 바로 콘솔창이 대답을 줍니다. console 창에 직접 입력을 해도 되고, source 창의 코드를 여러 방법을 통해서 console 창으로 전달해서 결과를 받을 수 도 있습니다. environment 창(이하 env 창)은 console 창에 입력이 되어서 현재 메모리에 기록되어 있는 상황을 보여주는 곳입니다. R은 변수가 메모리에 저장되어 있는 상태여야만 변수로써 사용할 수 있습니다. 그래서 env 창에서는 그렇게 메모리에 저장되어 있는 변수들의 이름과 내용을 확인할 수 있습니다. help 창은 window 탐색기와 같은 files, 차트 결과를 보여주는 plots, 설치나 불러온 패키지 상태를 보는 packages, 도움말을 보는 help 등 다양한 창으로 구성되어 있습니다. 아래에서 하나하나 중요한 기능을 보겠습니다. 1.2.1 source 창 source창 source 창에서 가장 중요한 기능은 ctrl+enter 입니다. ctrl+enter는 커서가 위치한 줄의 코드를 console 창으로 전달해서 R 엔진이 결과물을 주도록 하는 단축키입니다. 코드를 드래그해서 선택한 만큼의 코드를 실행할 때도 같은 단축키를 사용합니다. File &gt; New File 로 들어가시면 여러 종류의 파일을 만들 수 있는데, 각 파일에 따라 다른 추가 기능들이 나오기도 합니다. 1.2.2 console 창 console 창은 실제로 실행이 이루어지는 곳입니다. 여기서 가장 중요한 것은 아래 보이는 workding directory위치 입니다. R도 다른 개발 언어들 처럼 R 엔진이 실행되는 폴더의 위치가 지정되어 있습니다. R 엔진이 실행되는 위치를 workding directory라고 합니다. 그래서 파일을 불러오거나 하는 명령어는 workding directory를 기준으로 실행이 됩니다. 폴더의 위치를 입력하는 양식을 보통 경로라는 단어를 사용하고, 편의에 따라 절대경로와 상대경로를 사용합니다. workding directory가 문제가 되는 경우는 상대경로일 때 입니다. 상대경로는 . 이라는 표시를 현재 폴더라는 뜻으로 사용합니다. workding directory를 잘 모르고 실행하다 문제가 생기면 가장 해결하기 좋은 방법은 절대경로를 사용하는 것입니다. 혼자 사용하면 문제가 없지만 같이 사용하거나 다른 환경에서 사용해야 할 경우는 매번 경로를 수정해야 되는 문제가 생깁니다. 그렇다면 상대경로로 작성하되 동작방식을 하는게 중요합니다. 보통은 파일을 실행하는 위치로 결정되는데, console의 경우 처음 언어 엔진을 실행한 위치로 결정되기도 합니다. 처음 시작하시는 분들이 크게 하는 실수는 help 창 부분에서 사용하는 files에서 보는 위치로 workding directory가 계속 따라 바뀌는 것으로 오해하는 것입니다. files 창 내에서 실행하는 것 이외의 실행들은 대부분 위 사진의 위치에 있는 workding directory에서 실행된다고 알고 계시는 것이 중요합니다. 1.2.3 environment 창 env창 environment 창은 Environment 창과 History 창, git을 사용한다면 git 창이 보입니다. Build 창이 보일때가 있는데 이것은 package를 만들거나 소스를 가져와 컴파일할 때 사용하는 창으로 사용할 일이 있으시면 R packages을 참고하세요. env 창은 위에서 설명한 것 처럼 메모리에 등록한 변수들을 각 이름과 내용에 대해 간략히 보여줍니다. console 창에 ls()를 입력하면 나타나는 등록된 변수들의 이름과 같습니다. HIstory 창은 console 창에 입력한 순서대로 기록을 해주는 공간입니다. 이 곳에서는 명령어를 클릭한 후 To Console과 To Source를 사용할 수 있습니다. 어떻게 동작하는지는 한번 실행해봐주세요. git 창은 git의 기능을 GUI로 사용할 수 있게 제공합니다. commit, pull, push, log 등의 기능을 사용할 수 있습니다. 다음 장에서 git과 github에 대해 간단히 사용하는 법을 설명드리겠습니다. 1.2.4 help 창 help 창은 다른 곳에 비해 다양한 기능을 수행합니다. files는 윈도우에서의 탐색기와 같이 파일들을 찾아볼 수 있습니다. 조금 불편하긴 하지만 이름 바꾸기, 복사, 이동 등을 할 수 있습니다. 그리고 메모리에 올릴 데이터(csv, xlsx 등)를 왼쪽 클릭하면 아래 화면과 같이 view와 import를 할 수 있습니다. 물론 저는 명령어로 불러오는 것을 권장합니다. plot 창은 plot과 그 계열의 차트나 그림을 그리는 명령어의 결과물이 표시되는 곳입니다. 전에 그렸던 결과물이 계속 저장되서 전에 그렸던 그림을 다시 볼 수 도 있습니다. packages 창은 현재 시스템에 설치되어 있는 package들을 리스트로 보여주고, 현재 불러와져서 사용할 수 있는 package들을 체크 박스로 표시해줍니다. install, update 버튼도 있습니다. Packrat은 패키지 의존성 관리 도구로써 패키지들을 프로젝트 별로 독립적으로 관리해서 다른 환경에서 사용할 때 최대한 실행 환경을 유지할 수 있게 도와주는 역할을 합니다. help 창은 help(함수명), ?함수명 같이 함수의 설명서를 요구하는 명령어를 console 창에 입력했을 때 설명 문서를 보여주는 곳입니다. 각 세부적인 기능에 대해 계속 업데이트 하겠습니다. 1.3 프로젝트와 버전관리 RStudio는 사용 화면에 대화형 console 창을 항상 켜놓고 있는 형태의 IDE 입니다. 그렇다 보니 RStudio에서 직접 프로젝트라는 기능을 제공합니다. 프로젝트란 어떤 분석 프로젝트 단위 하나를 의미하며 그 프로젝트를 관리하는 것을 도와주는 도구들을 제공합니다. 1.3.1 폴더와 프로젝트 가장 간단하게는 .proj 파일을 생성하는 것입니다. 왼쪽 위에 File &gt; New Project &gt; New Diractory &gt; Empty Project 를 선택하신 후 폴더 이름을 입력하고 프로젝트를 만듭니다. 그러면 프로젝트 이름과 같은 폴더가 만들어 지고 그 안에 프로젝트이름.porj파일이 함께 생성됩니다. .proj 파일은 Tools &gt; Project Options에서 조절할 수 있는 정보들을 저장하고 있습니다. 그리고 더블 클릭을 통해 프로젝트을 오픈하면서 RStudio를 실행시킬 수 있습니다. 또한 workding directory를 프로젝트 폴더로 자동 지정해 줍니다. 프로젝트 내의 코드 작업물을 모두 상대경로를 편하게 사용할 수 있게 해줍니다. 다른 사람들에게 공유할 때도 폴더 째로 공유하고, .proj파일로 실행하면 다른 곳에서도 어느 정도 코드가 동작하는데 경로나 설정을 걱정하지 않을 수 있습니다. 1.3.1.1 재현성을 위한 패키지 의존성 관리도구 Packrat 각 프로젝트에서 사용하는 패키지를 프로젝트 폴더내에 관리할 수 있게 해줌으로써 더욱 코드 재현성을 보장하는 관리도구입니다. Tools &gt; Project Options 하위에 옵션이 있으며 체크박스를 체크하는 것으로 사용할 수 있습니다. 처음부터 프로젝트를 만들 때 선택할 수도 있습니다. 자세한 안내는 여기를 참고하세요. 1.3.2 버전관리도구 git 1.3.2.1 버전관리도구란 git은 현재 개발자들에게 가장 인기있는 버전관리도구 입니다. 버전관리도구란 파일의 변경사항을 저장하는 도구로 word 같은 곳에서 Ctrl+z 같은 것(되돌리기)을 수행하기 위해 변경이 생길때 마다 저장하는 것과 비슷한 기능을 수행합니다. 다른 점이라면 프로젝트와 같이 폴더별로 관리된다는 점, 변경상태에 대해서 추적할 파일을 git에게 알려주는 행위를 해야 한다는 점, 저장을 일부러 해야 한다는 점 정도가 차이점이라고 볼 수 있습니다. 각각 git init, git add, git commit 명령어에 대응되는 개념입니다. 1.3.2.2 git으로 버전 관리하기 git init은 명령을 실행한 위치의 폴더가 git이 관리하는 프로젝트 폴더임을 선언하는 명령어입니다. 위 그림처럼 .git이라는 폴더가 생기는데 여기에 버전관리를 위한 여러 정보들을 저장합니다. 앞에 .이 붙은 폴더는 unix 계열 OS에서 숨김파일을 뜻하고, 윈도우에서도 숨김 파일 옵션으로 생성됩니다. 숨김 파일을 보는 옵션을 설정하시면 확인하실 수 있습니다. 어쨌든 git을 사용하는 첫번째 방법을 배웠습니다. 1.3.2.3 git이 이해하는 세 가지 상태 git은 폴더 내에 있는 파일들을 전부 3가지 상태로 구분합니다. 그것은 tracked, modified, staged입니다. 각각 살펴보겠습니다. tracked는 말 그대로 파일이 추적되고 있는 상태다라는 뜻합니다. git이 추적할 파일을 지정해 주는 git add [파일 or 폴더명]을 통해 untracked 파일이 tracked 파일로 상태가 변경되고 git의 추적이 시작됩니다. 과거 용량 등의 관리가 중요할 때 의 기능으로 이해하고 있으며 최근의 git을 사용하기 위한 추가적인 지원도구들은 대부분 자동으로 git add .을 진행하여 폴더내의 모든 파일을 계속 tracked 상태를 유지해 줍니다. tracked 상태의 파일을 수정하면 modified 상태가 됩니다. track 이 시작되면 파일의 track 시작할 때의 상태를 저장해 두는데, 그것과 비교해서 다른 점이 발생하면 modified 상태로 git은 인지하고 있습니다. 하지만 아직 git이 달라진 점을 저장하지 않습니다. 달라진 것만 알고 있는 상태입니다. modified 상태의 파일은 아직 commit할 수 없습니다. stage 위에 올려서 commit 할 수 있는 상태로 만들어야 합니다. 즉, staged 상태는 commit을 할 대상 파일로 지정되었다는 뜻입니다. commit이란 처음 생성된 상태나 이전 commit된 상태와 현재 상태를 비교해서 달라진 점을 저장하는 것을 뜻합니다. 이 때 git은 달라진 점만 저장합니다. 저장하면서 주석과 같은 기능을 하는 commit message를 작성해 둘 수 있습니다. 이 메세지를 통해서 코드에서 주요하게 달라진 점이 무엇인지를 파악할 수 있습니다. 이렇게 git은 코드의 상태를 정의하고, commit을 통해 변경되는 지점들을 저장합니다. 그럼 git checkout을 이용해 저장된 commit의 위치로 자유롭게 움직일 수 있습니다. 1.3.2.4 로컬과 리모트 git은 협업을 위한 도구이기도 합니다. 그래서 직접 작업하는 프로젝트 공간인 local과 다른 사람들과 공유하기 위한 공동 프로젝트 공간인 remote가 있습니다. 모두 repository(줄여서 repo) 또는 저장소라는 표현을 씁니다. remote에 git으로 관리되고 있는 프로젝트가 있다고 생각해 봅시다. 그 remote repo의 주소를 가지고 local에 git clone [remote repo 주소]명령어로 복사를 합니다. 그리고 local에서 새로운 파일도 만들고 코드도 작성한 후에 위에서 말한 것 처럼 git add로 파일을 등록하고, git commit을 통해 변경 사항들을 저장합니다. 이제 local에 저장된 변경부분을 remote에 기록을 해야 하는데 git push라고 합니다. 1.3.3 github github은 현재 가장 인기있는 git remote repository service입니다. 많은 분들이 이렇게 헷갈리시는데, github는 정확히 git과 같은 것이 아닙니다. github은 git에서의 remote repo를 저장할 수 있는 공간을 제공하는 서비스입니다. 비슷한 서비스로는 bitbuket, gitlab 등이 있습니다. git과 비슷한 다른 버전관리 도구를 지원하기도 합니다. github은 git과 달리 remote repo끼리 clone과 push와 같은 기능을 수행하는 새로운 옵션을 제공합니다. 바로 fork와 pull request입니다. SNS처럼 좋아요를 의미하는 star도 있습니다. fork는 공유하기와 비슷한데, 자신의 remote repo에 다른 사람의 remote repo를 복사해 오는 것입니다. git clone과 비슷합니다. github내의 remote repo끼리 동작하는 것이기 때문에 remote repo와 local repo가 상호작용하는 동작과 다른 명령어를 사용합니다. pull request는 fork로 연결되어 있는 remote repo에 자신의 remote repo에 있는 코드를 pull 해가라고 요청하는 것입니다. fork를 한 후 수정한 코드를 원래 주인의 remote repo에 적용하는 것을 요청하는 명령입니다. 위와 같은 과정을 통해 github이 동작합니다. github은 git의 인기와 공개 저장소의 무제한 제공으로 세계에서 가장 인기있는 서비스가 되었고, 대부분의 오픈소스가 저장되고 개발되는 공간이 되었습니다. 오픈소스는 라이선스를 잘 지킨다면 소스코드를 사용해도 좋다고 선언한 코드들입니다. 많은 분들이 자신들의 코드를 공개하고, 결과물을 공유합니다. RStudio 또한 코드를 github에 공개하고 관리하고 있습니다. RStudio는 조금 복잡한 라이선스로 선언해서 편하게 사용할 수 있는 것은 아니지만 이렇게 코드를 공개하고 라이선스를 선언한 것을 오픈소스라고 합니다. 1.3.4 github과 패키지 생태계 R-core 팀이 관리하는 패키지 배포 서버인 cran은 매우 엄격한 패키지 사전 검열을 합니다. 그렇기 때문에 console에서 install.packeges() 한번에 편하게 패키지를 설치하고 사용할 수 있는 것입니다. 최근에는 사전 검열을 통과하기 전 버전의 패키지들이 코드 관리를 위해 github에 저장소를 운영하기도 합니다. github은 인기있는 저장소이기 때문에 구글 검색을 통해 사용자들이 유입되기 좋은 곳입니다. 특히 패키지 운영을 위한 홈페이지, wiki, readme 파일 관리등의 기능을 충분히 지원하는 등 좋은 점이 많습니다. 많은 R 패키지 개발자들도 코드 관리를 github에서 하고 있습니다. 최근에는 개발 버전은 github에, 안정화 버전은 cran에 등록해서 사용할 수 있게 하는 문화가 자리잡혀 있습니다. 1.4 도움말 cran에 등록된 패키지들은 모두 도움말이 충분히 작성되어 있습니다. Vignette라는 세부 패키지 설명이나 아예 블로그 등에서 패키지 사용법이나 작업 순서들을 설명한 패키지도 있습니다. 모두 검색을 통해서 찾아야 되긴 하지만 최소한의 설명서가 내장되어 있으니 그 것을 먼저 확인하는 것이 좋습니다. 도움말은 ?함수명이나 help(함수명)으로 실행할 수 있습니다. ?함수명 "],
["data-type.html", "2 대부분의 에러 문제를 해결할 수 있는 기초 자료형에 대한 이해 2.1 기초 자료형 2.2 벡터 2.3 메트릭스 2.4 팩터 2.5 리스트 2.6 데이터프레임 2.7 날짜", " 2 대부분의 에러 문제를 해결할 수 있는 기초 자료형에 대한 이해 자료형에 대해 알고 있는 것과 자료형을 파악하는 것은 매우 중요합니다. 함수가 입력 데이터로 사용이 가능한 데이터를 입력 데이터로 지정해 주어야 실행이 되기 때문인데요. 많은 분들이 여기에서 문제가 발생합니다. 특히 작업을 진행하면서 기대하지 않은 자료형으로 중간 결과물이 나오는 경우에는 이후에 생기는 문제에 대해서 이해하기 어려울 수 있습니다. 그렇기 때문에 기본 R에서 제공하는 자료형에 대해서 공부해 두는 것은 대부분의 함수가 사용하는 데이터의 형식을 공부하는 것과 같습니다. 물론 패키지마다 자체 자료형을 정의하기도 합니다. 하지만 지금 기초 자료형을 공부하면서 새로운 자료형을 파악하는 방법을 자연스럽게 배울 수 있을 거라 생각합니다. 자료형을 파악하는 방법은 class 함수를 사용하는 것입니다. x &lt;- 1 class(1) #&gt; [1] &quot;numeric&quot; class(x) #&gt; [1] &quot;numeric&quot; class(&quot;x&quot;) #&gt; [1] &quot;character&quot; ?class를 입력해서 class 함수에 대해서 파악해 보세요. 위에 class 함수의 결과로 나오는 것이 자료형의 종류입니다. numeric은 숫자를, character는 글자를 뜻합니다. 이제 아래에서 하나하나 확인해 보겠습니다. 기초 자료형에 대해서 MS의 edX 강의, datacamp, r-tutor의 내용을 참고했습니다. 2.1 기초 자료형 2.1.1 논리형 logical logical(로지컬) 자료형은 기다 아니다 같이 True, False를 표현하기 위해 만들어진 자료형입니다. R에서는 각각 두 가지 표현법이 있습니다. TRUE #&gt; [1] TRUE class(TRUE) #&gt; [1] &quot;logical&quot; T #&gt; [1] TRUE class(T) #&gt; [1] &quot;logical&quot; FALSE #&gt; [1] FALSE class(FALSE) #&gt; [1] &quot;logical&quot; F #&gt; [1] FALSE class(F) #&gt; [1] &quot;logical&quot; 언어에 따라 True, False를 채택하는 경우도 있습니다만 R의 경우 위와 같이 전부 대문자인 글자를 logical 자료형으로 인식합니다. 이렇게 class 함수를 이용해서 자료형이 무엇인지 파악하는 것도 중요하지만, 조건문 등을 통해서 일을 자동적으로 수행하게 시키기 위해서는 class 같이 결과값이 다양한 것 보다는 logical 자료형으로 결과가 나오는 것이 앞으로 배우게 될 if 문 등에 조건으로 사용하기 좋습니다. 아래와 같은 is.logical 함수는 괄호안의 데이터가 logical 자료형이 맞는지를 물어보는 함수 입니다. 다른 자료형도 대부분 is.자료형이름을 함수로 사용할 수 있습니다. test &lt;- TRUE is.logical(test) #&gt; [1] TRUE is.logical(TRUE) #&gt; [1] TRUE is.logical(&quot;test&quot;) #&gt; [1] FALSE test &lt;- &quot;1&quot; is.logical(test) #&gt; [1] FALSE R Studio에서는 함수의 자동완성 기능을 제공합니다. is.을 입력해서 다양한 자료형을 확인하는 명령어를 구경해보세요. 2.1.2 숫자형 numeric numeric(뉴메릭) 자료형은 그 영어 뜻이 숫자의인 것 같이 숫자를 표현하는 자료형입니다. 물론 복소수 같이 다른 여러 표현들도 사용할 수 있습니다만, R에서 숫자는 보통 numeric 자료형으로 처리합니다. 2 #&gt; [1] 2 class(2) #&gt; [1] &quot;numeric&quot; is.numeric(2) #&gt; [1] TRUE numeric은 소수점 이하 값을 가지는 숫자도 포함합니다. 2.5 #&gt; [1] 2.5 class(2.5) #&gt; [1] &quot;numeric&quot; is.numeric(2.5) #&gt; [1] TRUE 숫자를 표현하는 자료형으로 integer도 있습니다. 영어 뜻 그대로 정수를 표현하는 자료형인데요, 소수점이 없는 숫자를 표현할 때 사용합니다. R에서는 integer로 바로 인식시키기 위해서 정수인 숫자 뒤에 L(대문자 엘)을 붙여서 표현합니다. 2L #&gt; [1] 2 class(2L) #&gt; [1] &quot;integer&quot; is.numeric(2L) #&gt; [1] TRUE is.integer(2L) #&gt; [1] TRUE integer는 numeric에 비해 차지하는 메모리가 적으며 때문에 연산이 좀 더 빠르다는 장점이 있습니다. 2.1.3 글자형 character character(캐릭터) 자료형은 그 영어 뜻이 문자인 것 같이 글자를 표현하는 자료형입니다. R에서는 변수와 글자를 구분하기 위해서 글자의 앞뒤에 &quot;를 붙이는데요. '도 같은 역할을 합니다. 그래서 &quot;나 ' 사이에 있는 것은 모두 글자, 즉 character로 인식합니다. &quot;2&quot; #&gt; [1] &quot;2&quot; class(&quot;2&quot;) #&gt; [1] &quot;character&quot; is.numeric(&quot;2&quot;) #&gt; [1] FALSE is.character(&quot;2&quot;) #&gt; [1] TRUE 한글도 됩니다. is.character(&quot;한글&quot;) #&gt; [1] TRUE 심지어 &quot; 사이에 있는 ', ' 사이에 있는 &quot;도 글자로 인식합니다. 이걸 이용해서 글자내에 &quot;나 '가 들어가야 할 경우, 안에 들어가지 않는 것을 글자로 인식시키기 위한 표시로 사용하기도 합니다. &quot;&#39;&quot; #&gt; [1] &quot;&#39;&quot; is.character(&quot;&#39;&quot;) #&gt; [1] TRUE &#39;&quot;&#39; #&gt; [1] &quot;\\&quot;&quot; is.character(&#39;&quot;&#39;) #&gt; [1] TRUE 이렇게 다른 자료형의 기반이 되는 기초 자료형 3개에 대해 알아보았습니다. 이 각각은 지금까지 데이터가 한 개인 경우였습니다. 그렇다면 이 자료형들이 모여 이루는 새로운 자료형에 대해서 알아보겠습니다. 2.2 벡터 2.2.1 하나의 기초 자료형만으로 구성된 1차원 데이터 집합 vector(벡터) 자료형은 가장 간단하게 하나의 자료형에 해당하는 데이터들의 1차원적인 집합입니다. vector를 만드는 가장 간단한 함수는 c입니다. ?c를 실행해서 내용을 한 번 읽어주세요. vec_char &lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) vec_char #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; class(vec_char) #&gt; [1] &quot;character&quot; is.vector(vec_char) #&gt; [1] TRUE is.character(vec_char) #&gt; [1] TRUE vec_char는 character이기도 하면서 vector입니다. 그럼 이번엔 숫자 벡터를 한번 만들어 보겠습니다. vec_num &lt;- c(1,2,3,4,5) vec_num #&gt; [1] 1 2 3 4 5 class(vec_num) #&gt; [1] &quot;numeric&quot; is.vector(vec_num) #&gt; [1] TRUE is.numeric(vec_num) #&gt; [1] TRUE 이번엔 vec_num이 numeric이기도 하면서 vector입니다. 마지막으로 논리 벡터를 만들어 볼까요. vec_logi &lt;- c(T,T,T,F,F,T) vec_logi #&gt; [1] TRUE TRUE TRUE FALSE FALSE TRUE class(vec_logi) #&gt; [1] &quot;logical&quot; is.vector(vec_logi) #&gt; [1] TRUE is.logical(vec_logi) #&gt; [1] TRUE 지금까지 살펴본 바에 따르면 vector라는 사실은 class로 파악할 수 없고, is.vector로 확인할 수 있습니다. 사실 파악할 수 없다보다는 파악할 필요가 없습니다. vector는 한 번에 같이 처리할 수 있는 데이터를 묶어둔 것이기 때문에 한 vector로 묶인 데이터들은 모두 자료형이 강제로 같게 만들어 집니다. 아래와 같이 다양한 시도를 해서 강제로 자료형이 통일되게 저장되는 것을 확인해 보세요. vec_test1 &lt;- c(1,2,3,&quot;test&quot;) vec_test1 #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;test&quot; class(vec_test1) #&gt; [1] &quot;character&quot; 이렇게 vector는 하나의 기초 자료형만으로 구성된 1차원 데이터 집합인 것을 알게 되었습니다. 그럼 이제 vector에서 일부의 데이터만 불러오는 방법을 알아보겠습니다. 2.2.2 vector에서 일부 데이터 불러오기 데이터를 모아 놓은 것은 좋은 전략이지만 그 중 일부를 자유롭게 사용할 수 있을 때 더욱 빛을 발하는 것 같습니다. vector는 같은 종류의 데이터를 한 줄로 늘어뜨려 놓은 것으로 상상하시면 좋을 것 같은데, 왜냐면 위치로 데이터의 일부를 선택하기 위해서 입니다. 컴퓨터 언어에서 무엇을 언급하는 방법은 두 가지가 있습니다. 하나는 임의의 이름으로 지정된 주소값 자체를 언급하는 것이고, 다른 하나는 그 주소값에 이름을 부여해서 그 이름을 부르는 것입니다. 정확한 비유는 아닙니다만, vector에서 특정 위치에 있는 값을 부르는 것은 위치의 주소값이나 지정해둔 이름으로 값을 부르는 것과 비슷합니다. 값의 순서라고 볼 수 있는 주소값을 index라고 합니다. R에서 index를 사용하는 방법은 [ ](대괄호)를 변수뒤에 붙여서 사용합니다. vec_ind &lt;- c(&quot;b&quot;,&quot;a&quot;,&quot;ab&quot;,&quot;b&quot;,&quot;o&quot;,&quot;ab&quot;) vec_ind[1] #&gt; [1] &quot;b&quot; 위에서 지정해둔 이름으로 값을 부르는 방법이 있다고 했습니다. 그러면 우선 vector의 값에 이름을 부여하는 방법을 살펴보겠습니다. 새롭게 살펴볼 명령어는 names입니다. ?names를 실행해서 살펴보세요. blood_type1 &lt;- c(bob = &quot;A&quot;, sam = &quot;B&quot;, john=&quot;O&quot;,jim=&quot;AB&quot;,tom=&quot;A&quot;) blood_type1 #&gt; bob sam john jim tom #&gt; &quot;A&quot; &quot;B&quot; &quot;O&quot; &quot;AB&quot; &quot;A&quot; names(blood_type1) #&gt; [1] &quot;bob&quot; &quot;sam&quot; &quot;john&quot; &quot;jim&quot; &quot;tom&quot; 위의 첫번째 방법은 처음 vector를 만들 때 부터 이름을 짓고 시작하는 것입니다. =를 기준으로 왼쪽이 이름, 오른쪽이 이름에 해당하는 값입니다. 그럼 다른 방법을 보겠습니다. blood_type2 &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;O&quot;,&quot;AB&quot;,&quot;A&quot;) blood_type2 #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;O&quot; &quot;AB&quot; &quot;A&quot; names(blood_type2) #&gt; NULL blood_type2_name &lt;- c(&quot;bob&quot;, &quot;sam&quot;, &quot;john&quot;, &quot;jim&quot;, &quot;tom&quot;) blood_type2_name #&gt; [1] &quot;bob&quot; &quot;sam&quot; &quot;john&quot; &quot;jim&quot; &quot;tom&quot; names(blood_type2) &lt;- blood_type2_name blood_type2 #&gt; bob sam john jim tom #&gt; &quot;A&quot; &quot;B&quot; &quot;O&quot; &quot;AB&quot; &quot;A&quot; names(blood_type2) #&gt; [1] &quot;bob&quot; &quot;sam&quot; &quot;john&quot; &quot;jim&quot; &quot;tom&quot; names 함수가 vector의 이름을 보여주는 함수이기도 하면서 값을 지정받을 수 있는 변수의 기능도 합니다. names(blood_type2) 전체가 하나의 변수로 동작하는 것이지요. 그래서 처음 선언한 vector에 이름이 없는 것을 확인하고 새롭게 이름에 해당하는 변수 blood_type2_name을 선언한 후에 names(blood_type2)에 선언해줌으로써 이름을 작성했습니다. 두번째 방법을 보면 언제든 새롭게 이름을 지정해 줄 수 있음을 알 수 있습니다. 원래 내용으로 돌아가서, 그럼 이제 이름으로 그 위치에 해당하는 값을 출력해 보겠습니다. blood_type1 &lt;- c(bob = &quot;A&quot;, sam = &quot;B&quot;, john=&quot;O&quot;,jim=&quot;AB&quot;,tom=&quot;A&quot;) blood_type1[bob] 조금 이상합니다. Error: object 'bob' not found라고 하면서 동작하질 않네요. Error 메세지는 함수가 작동하는데 문제가 있어서 실행이 되질 않았다는 뜻입니다. (참고로 Warning은 실행은 됬지만 기대하는 결과가 아닐 수 있으니 확인해보라는 뜻입니다.) object는 지금까지 한글로 변수라고 불렀습니다. 그럼 변수인 bob이 없다는 에러가 발생한 겁니다. 글자형에서 R에서는 변수와 글자를 구분하기 위해서 글자의 앞뒤에 &quot;를 붙인다고 했습니다. 그렇다면 blood_type1[bob]에서 bob의 앞뒤에 &quot;표시를 하지 않았기 때문에 R이 변수로 인식한 듯합니다. 그럼 &quot;로 묶어서(앞뒤에 표시해서) 다시 실행해 보겠습니다. blood_type1 &lt;- c(bob = &quot;A&quot;, sam = &quot;B&quot;, john=&quot;O&quot;,jim=&quot;AB&quot;,tom=&quot;A&quot;) blood_type1[&quot;bob&quot;] #&gt; bob #&gt; &quot;A&quot; 이제 원하는 결과가 나왔습니다. 이런 문법에 대해서는 규칙을 정확히 이해하는 것도 중요하지만 계속 console에 입력해보면서 테스트를 하는 것이 매우 중요합니다. 그렇게 하면 자주 사용하는 것은 익숙해지고, 기억이 흐릿한 것은 확인해가며 코드를 작성할 수 있게 됩니다. 더 확인해봐야 할 것이 있습니다. 지금까지 한 개만 불러오는 것을 했는데, 여러 개를 동시에 해도 되는지를 확인해 보겠습니다. blood_type1 &lt;- c(bob = &quot;A&quot;, sam = &quot;B&quot;, john=&quot;O&quot;,jim=&quot;AB&quot;,tom=&quot;A&quot;) blood_type1[c(&quot;bob&quot;,&quot;john&quot;)] #&gt; bob john #&gt; &quot;A&quot; &quot;O&quot; 여러 개도 가능합니다. 여러 개를 지정하기 위해 c함수를 함께 사용한 것에 주목해 주세요. c로 이름을 묶어서 사용하지 않으면 어떻게 되는지 확인해 보세요. blood_type1 &lt;- c(bob = &quot;A&quot;, sam = &quot;B&quot;, john=&quot;O&quot;,jim=&quot;AB&quot;,tom=&quot;A&quot;) blood_type1[&quot;bob&quot;,&quot;john&quot;] Error in blood_type1[&quot;bob&quot;, &quot;john&quot;] : incorrect number of dimensions이라는 Error를 보셨으면 맞게 동작하는 것입니다. 메세지를 한번 잘 보겠습니다. dimension은 차원이라는 뜻으로 제가 vector는 1차원 데이터 집합이라는 표현을 썼었습니다. 그렇다면 차원이 맞지 않게 요청이 되었다는 뜻입니다. R은 [ ]안에서 ,(쉼표)는 차원을 구분하는 것으로 인식합니다. 예를 들어 [ , , , ]라고 하면 4차원 데이터를 뜻한다고 할 수 있습니다. 그렇기 때문에 blood_type1[&quot;bob&quot;,&quot;john&quot;]은 저희가 의도하지 않는 방식으로 R이 이해한 것입니다. R이 이해하는 대로 해석하면 첫번째 차원은 이름이 ’bob’인 데이터를, 두번째 차원은 이름이 ’john’인 데이터를 불러옴이 됩니다. 하지만 우리는 첫번째 차원에서 이름이 ’bob’인 데이터와 이름이 ’john’인 데이터를 불러옴을 실행하고 싶기 때문에 같은 차원에서 두 개의 이름을 사용했다는 것을 R에게 알려줘야 합니다. 그래서 c 함수를 사용해서 이름을 묶어, 여러 데이터를 불러오는 이름을 사용할 때 vector를 사용한 것입니다. 이 방법은 차원이 늘어나거나 하더라도 같은 문법을 사용합니다. 그럼 이제 2차원 데이터 집합인 matrix를 살펴보겠습니다. 2.3 메트릭스 2.3.1 vector의 2차원 확장 matrix는 간단하게 1차원의 vector를 2차원으로 확장한 것입니다. 여기서 2차원이란 1차원 vector가 두 줄이 생겼다는 것이 아니라 행과 열로 2차원을 표현하게 됩니다. matrix는 많이 보시는 엑셀 시트와 같은 형태를 띕니다. 차원의 의미가 여러 가지가 가능하겠습니다만, 지금의 차원은 데이터를 표현하는 축의 갯수라고 이해하시면 좋을 것 같습니다. 소개해야 할 자료형 중에 array가 있는데 배열이라는 뜻입니다. vector는 1차원 array의 특별한 이름이고, matrix는 2차원 array의 특별한 이름입니다. 3차원 이상 부터는 전부 n차원 array라고 합니다. 그래서 vector와 matrix, array는 앞서 vector에서 확인했던 문법적 규칙과 모두 같은 규칙을 따릅니다. 그럼 이제 matrix를 한번 만들어 보겠습니다. matrix(1:6, nrow = 2) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 matrix(1:6, ncol = 3) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 matrix(1:6, nrow = 2, byrow = TRUE) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 위에서 1:6은 1부터 6까지의 숫자 벡터를 뜻합니다. c(1,2,3,4,5,6)과 같습니다. row는 행을, col은 column의 줄임말로 열을 나타내구요. byrow옵션이 TRUE면 row방향으로 먼저 벡터를 나열하라는 뜻입니다. matrix는 행열의 크기를 지정하기 때문에 지정된 크기보다 작은 양의 데이터를 선언할 때 어떻게 동작할 것인지 정해져 있습니다. matrix(1:3, nrow = 2, ncol = 3) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 2 #&gt; [2,] 2 1 3 matrix(1:4, nrow = 2, ncol = 3) #&gt; Warning in matrix(1:4, nrow = 2, ncol = 3): data length [4] is not a sub- #&gt; multiple or multiple of the number of columns [3] #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 1 #&gt; [2,] 2 4 2 첫번째 명령에서는 부족한 갯수만큼 있던 것을 다시 사용해서 자동으로 채워줬네요. 두번째 명령에서도 같은 방식으로 동작한 것 같은데 Warning 메세지가 나왔습니다. 행의 갯수의 약수거나 배수이지 않다는 것을 알려줌으로써 의도적인 행동인지 확인할 수 있게 도와줍니다. 결과를 확인해보면, 4개까지 사용하고 다시 처음부터 1, 2를 사용하면서 행열의 크기만큼 데이터를 채웠습니다. Warning이 나오면 확인해보면 좋겠네요. 행열의 모양을 배우면서 이제 cbind와 rbind를 확인해 보겠습니다. cbind는 열 방향으로 묶는다.라는 의미이구요. rbind는 행 방향으로 묶는다는 뜻입니다. 아래 코드로 어떻게 행열의 모양이 달라지는지 확인해 보세요. cbind(1:3, 1:3) #&gt; [,1] [,2] #&gt; [1,] 1 1 #&gt; [2,] 2 2 #&gt; [3,] 3 3 rbind(1:3, 1:3) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 1 2 3 m &lt;- matrix(1:6, byrow = TRUE, nrow = 2) m #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 rbind(m, 7:9) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 #&gt; [3,] 7 8 9 cbind(m, c(10, 11)) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 2 3 10 #&gt; [2,] 4 5 6 11 vector에서 사용한 names처럼, 행열에 대응하는 함수가 있습니다. rownames, colnames가 그것인데요. ?rownames와 ?colnames로 자세한 내용을 더 확인해 보시기 바랍니다. m &lt;- matrix(1:6, byrow = TRUE, nrow = 2) m #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 rownames(m) #&gt; NULL rownames(m) &lt;- c(&quot;row1&quot;, &quot;row2&quot;) m #&gt; [,1] [,2] [,3] #&gt; row1 1 2 3 #&gt; row2 4 5 6 colnames(m) #&gt; NULL colnames(m) &lt;- c(&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;) m #&gt; col1 col2 col3 #&gt; row1 1 2 3 #&gt; row2 4 5 6 vector처럼 처음부터 만들 때 이름을 지정해 줄 수도 있습니다. m &lt;- matrix(1:6, byrow = TRUE, nrow = 2, dimnames = list(c(&quot;row1&quot;, &quot;row2&quot;), c(&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;))) m #&gt; col1 col2 col3 #&gt; row1 1 2 3 #&gt; row2 4 5 6 matrix도 vector와 같이 한 matrix내의 데이터는 모두 같은 자료형이어야 합니다. 이건 자연스럽다고 생각하는 건지 Warning도 주지 않으니 조심하셔야 합니다. num &lt;- matrix(1:8, ncol = 2) char &lt;- matrix(LETTERS[1:6], nrow = 4, ncol = 3) cbind(num, char) #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] &quot;1&quot; &quot;5&quot; &quot;A&quot; &quot;E&quot; &quot;C&quot; #&gt; [2,] &quot;2&quot; &quot;6&quot; &quot;B&quot; &quot;F&quot; &quot;D&quot; #&gt; [3,] &quot;3&quot; &quot;7&quot; &quot;C&quot; &quot;A&quot; &quot;E&quot; #&gt; [4,] &quot;4&quot; &quot;8&quot; &quot;D&quot; &quot;B&quot; &quot;F&quot; 2.3.2 matrix에서 일부 데이터 불러오기 matrix에서 일부 데이터를 불러오는 방법은 vector와 완전히 같습니다. vector에서 [ ]를 설명하면서 차원에 대해 이야기 했었는데요. matrix는 2차원이기 때문에 중간에 쉼표가 들어가야 합니다. m &lt;- matrix(sample(1:15, 12), nrow = 3) m #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 2 15 10 9 #&gt; [2,] 12 1 3 7 #&gt; [3,] 8 5 6 11 m[1,3] #&gt; [1] 10 m[3,2] #&gt; [1] 5 쉼표만 사용하고 어느 하나의 차원을 지정하지 않으면, 모두 불러온 것으로 가정합니다. m[3,] #&gt; [1] 8 5 6 11 m[,3] #&gt; [1] 10 3 6 신기하게도, 1차원인 vector의 일부 데이터 불러로기의 문법도 사용할 수 있습니다. m9가 어느 위치의 값인지 잘 찾아보시기 바랍니다. m[4] #&gt; [1] 15 m[9] #&gt; [1] 6 여전히 vector와 같이 어느 한 차원 내에서 여러개를 사용하기 위해서는 c와 함께 사용합니다. m[2, c(2, 3)] #&gt; [1] 1 3 m[c(1, 2), c(2, 3)] #&gt; [,1] [,2] #&gt; [1,] 15 10 #&gt; [2,] 1 3 m[c(1, 3), c(1, 3, 4)] #&gt; [,1] [,2] [,3] #&gt; [1,] 2 10 9 #&gt; [2,] 8 6 11 역시 이름을 사용해서 일부 데이터만 불러오는 것도 가능합니다. rownames(m) &lt;- c(&quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;) colnames(m) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) m #&gt; a b c d #&gt; r1 2 15 10 9 #&gt; r2 12 1 3 7 #&gt; r3 8 5 6 11 m[2,3] #&gt; [1] 3 m[&quot;r2&quot;,&quot;c&quot;] #&gt; [1] 3 m[2,&quot;c&quot;] #&gt; [1] 3 m[3, c(&quot;c&quot;, &quot;d&quot;)] #&gt; c d #&gt; 6 11 2.4 팩터 2.4.1 명목형 변수 R에 대해서 이야기 하면서 통계에 대한 이야기가 나오지 않을 수가 없는데요. factor는 categorical data를 표현하기 위해 만들어진 자료형이기 때문입니다. 통계에서 사용하는 자료형은 여기를 참고하세요. 가장 대표적인 categorical data인 혈액형을 예시로 factor를 사용해 보겠습니다. blood &lt;- c(&quot;B&quot;, &quot;AB&quot;, &quot;O&quot;, &quot;A&quot;, &quot;O&quot;, &quot;O&quot;, &quot;A&quot;, &quot;B&quot;) blood #&gt; [1] &quot;B&quot; &quot;AB&quot; &quot;O&quot; &quot;A&quot; &quot;O&quot; &quot;O&quot; &quot;A&quot; &quot;B&quot; str(blood) #&gt; chr [1:8] &quot;B&quot; &quot;AB&quot; &quot;O&quot; &quot;A&quot; &quot;O&quot; &quot;O&quot; &quot;A&quot; &quot;B&quot; blood_factor &lt;- factor(blood) blood_factor #&gt; [1] B AB O A O O A B #&gt; Levels: A AB B O str(blood_factor) #&gt; Factor w/ 4 levels &quot;A&quot;,&quot;AB&quot;,&quot;B&quot;,&quot;O&quot;: 3 2 4 1 4 4 1 3 자료의 상태를 파악하는 함수로 str를 사용했습니다. str은 변수의 구조가 어떻게 구성되어 있는지를 보여주는 함수로, 데이터를 파악하는데 좋은 방법입니다. 비슷한 다른 방법들로, summary, head 등이 있습니다. ?str, ?summary, ?head를 입력해서 내용을 확인해 보세요. chr [1:8] &quot;B&quot; &quot;AB&quot; &quot;O&quot; &quot;A&quot; &quot;O&quot; &quot;O&quot; &quot;A&quot; &quot;B&quot; 에서 chr는 character의 줄임 표현입니다. 그 다름 [1:8]은 데이터가 8개 있다는 뜻입니다. 그 이후에는 8개의 데이터가 모두 출력되었습니다. facter는 character와 다르게 Levels: A AB B O라는 줄이 추가 되었습니다. 그리고 데이터를 표현할 때 &quot;가 없어졌네요. 우선 그것만으로도 character가 아님을 판단할 수 있습니다. str(blood_factor)의 결과도 보겠습니다. Factor w/ 4 levels &quot;A&quot;,&quot;AB&quot;,&quot;B&quot;,&quot;O&quot;: 3 2 4 1 4 4 1 3에서 독특한 부분이 있습니다. 데이터가 숫자로 되어 있네요. 데이터와 비교해 보면 levels &quot;A&quot;, &quot;AB&quot;, &quot;B&quot;, &quot;0&quot;에서 3번째는 &quot;B&quot;입니다. 첫번째 데이터가 &quot;B&quot;인걸 보니 숫자는 levels에서 몇 번째 데이터인지를 뜻하는 것 같습니다. 다른 숫자들도 확인해 보세요. vector처럼 변수에 선언할 때 처음부터 levels를 지정할 수 도 있습니다. 순서를 지정하는 것도 가능합니다. 처음에 만든 blood_factor와 blood_factor2가 어떻게 다른지 비교해 보세요. blood_factor2 &lt;- factor(blood, levels = c(&quot;O&quot;, &quot;A&quot;, &quot;B&quot;, &quot;AB&quot;)) blood_factor2 #&gt; [1] B AB O A O O A B #&gt; Levels: O A B AB str(blood_factor2) #&gt; Factor w/ 4 levels &quot;O&quot;,&quot;A&quot;,&quot;B&quot;,&quot;AB&quot;: 3 4 1 2 1 1 2 3 str(blood_factor) #&gt; Factor w/ 4 levels &quot;A&quot;,&quot;AB&quot;,&quot;B&quot;,&quot;O&quot;: 3 2 4 1 4 4 1 3 names처럼 levels도 중간에 바꿀 수 있습니다. labels라는 것도 있는데, 이것은 데이터의 값을 뜻합니다. 어떻게 달라지는지 확인해 보세요. blood &lt;- c(&quot;B&quot;, &quot;AB&quot;, &quot;O&quot;, &quot;A&quot;, &quot;O&quot;, &quot;O&quot;, &quot;A&quot;, &quot;B&quot;) blood_factor &lt;- factor(blood) blood_factor #&gt; [1] B AB O A O O A B #&gt; Levels: A AB B O levels(blood_factor) &lt;- c(&quot;BT_A&quot;, &quot;BT_AB&quot;, &quot;BT_B&quot;, &quot;BT_O&quot;) blood_factor #&gt; [1] BT_B BT_AB BT_O BT_A BT_O BT_O BT_A BT_B #&gt; Levels: BT_A BT_AB BT_B BT_O factor(blood, labels = c(&quot;BT_A&quot;, &quot;BT_AB&quot;, &quot;BT_B&quot;, &quot;BT_O&quot;)) #&gt; [1] BT_B BT_AB BT_O BT_A BT_O BT_O BT_A BT_B #&gt; Levels: BT_A BT_AB BT_B BT_O factor는 명목형 변수여서 크기를 비교할 수 없습니다. blood &lt;- c(&quot;B&quot;, &quot;AB&quot;, &quot;O&quot;, &quot;A&quot;, &quot;O&quot;, &quot;O&quot;, &quot;A&quot;, &quot;B&quot;) blood_factor &lt;- factor(blood) blood_factor[1] &lt; blood_factor[2] #&gt; Warning in Ops.factor(blood_factor[1], blood_factor[2]): &#39;&lt;&#39; not meaningful #&gt; for factors #&gt; [1] NA 하지만 크기를 비교할 수 있는 형태로 선언할 수 도 있습니다. tshirt &lt;- c(&quot;M&quot;, &quot;L&quot;, &quot;S&quot;, &quot;S&quot;, &quot;L&quot;, &quot;M&quot;, &quot;L&quot;, &quot;M&quot;) tshirt_factor &lt;- factor(tshirt, ordered = TRUE, levels = c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;)) tshirt_factor #&gt; [1] M L S S L M L M #&gt; Levels: S &lt; M &lt; L tshirt_factor[1] &lt; tshirt_factor[2] #&gt; [1] TRUE 2.5 리스트 2.5.1 다른 종류의 자료형들이 함께 지금까지 전부 같은 자료형의 데이터가 모여 있는 형태의 자료형을 알아봤습니다. 같은 자료형으로 구성하는 것은 계산의 효율등 분명한 장점도 있지만, 그것을 사용하는 사람이 이해하기 어렵거나 불편할 때가 있습니다. 특히 다양한 자료형으로 구성된 데이터일 때 하나의 변수로 관리하기 위해서는 list를 사용해 합니다. 아래 c와 list로 만든 데이터를 비교해 보겠습니다. c(&quot;Rsome times&quot;, 190, 5) #&gt; [1] &quot;Rsome times&quot; &quot;190&quot; &quot;5&quot; list(&quot;Rsome times&quot;, 190, 5) #&gt; [[1]] #&gt; [1] &quot;Rsome times&quot; #&gt; #&gt; [[2]] #&gt; [1] 190 #&gt; #&gt; [[3]] #&gt; [1] 5 song &lt;- list(&quot;Rsome times&quot;, 190, 5) is.list(song) #&gt; [1] TRUE list 역시 is.list 함수가 있네요. c로 만들어진 데이터는 자료형을 강제로 전부 character로 바꾸었습니다. list는 데이터가 주욱 늘어지고, 숫자들은 숫자 데이터로 표현된 것 같습니다. 이 때 처음 보는 것이 있는데요. [[ ]]입니다. 이것은 vector가 하나의 자료형으로만 이루어져야 하는 점에 착안하여, vector를 여러 개 합쳐 list를 만듬으로써 문제를 해결했습니다. 그렇기 때문에 일부의 데이터를 불러오는 [ ]과 비슷하지만 합쳐져 있는 그 내부의 vector를 불러오는 [[ ]] 문법이 만들어 지게 되었습니다. [ ]과 [[ ]]를 실험해 보세요. song[3] #&gt; [[1]] #&gt; [1] 5 class(song[3]) #&gt; [1] &quot;list&quot; song[[3]] #&gt; [1] 5 class(song[[3]]) #&gt; [1] &quot;numeric&quot; list도 다른 자료형들 처럼 names를 사용합니다. song &lt;- list(&quot;Rsome times&quot;, 190, 5) names(song) &lt;- c(&quot;title&quot;, &quot;duration&quot;, &quot;track&quot;) song #&gt; $title #&gt; [1] &quot;Rsome times&quot; #&gt; #&gt; $duration #&gt; [1] 190 #&gt; #&gt; $track #&gt; [1] 5 이번엔 [[ ]] 위치에 $title 같이 $ + names의 문법이 나타났습니다. 이것이 list의 이름을 짓는 방법입니다. 이름으로 데이터를 부르는 방법은 더 복잡한 모양의 데이터를 만들고 실습해보기로 하고, list가 가진 다른 특성을 확인해 보겠습니다. song &lt;- list(title = &quot;Rsome times&quot;, duration = 190, track = 5) str(song) #&gt; List of 3 #&gt; $ title : chr &quot;Rsome times&quot; #&gt; $ duration: num 190 #&gt; $ track : num 5 similar_song &lt;- list(title = &quot;R you on time?&quot;, duration = 230) song &lt;- list(title = &quot;Rsome times&quot;, duration = 190, track = 5, similar = similar_song) str(song) #&gt; List of 4 #&gt; $ title : chr &quot;Rsome times&quot; #&gt; $ duration: num 190 #&gt; $ track : num 5 #&gt; $ similar :List of 2 #&gt; ..$ title : chr &quot;R you on time?&quot; #&gt; ..$ duration: num 230 list 안에 list가 들어가 있네요 str로 확인해 보니 list 안에 list가 ..$로 들여쓰기 되어 표현되어 있습니다. 데이터 표현도 List of 2라고 str(song)의 맨 윗줄(List of 4)과 같은 모양이 보입니다. 이것처럼 list는 대부분의 자료형을 요소로 가질 수 있습니다. list는 인터넷에서 많이 사용하는 자료형인 JSON에 대응됩니다. 과거에는 XML도 사용했다고 알고 있는데, 최근에는 많은 곳에서 JSON으로 사용하고 있습니다. JSON에 대해서는 이곳의 예제를 참고하세요 library(N2H4) url&lt;-&quot;http://news.naver.com/main/read.nhn?mode=LSD&amp;mid=shm&amp;sid1=100&amp;oid=437&amp;aid=0000152054&quot; tem&lt;-getComment(url) #&gt; [1] &quot;success : TRUE&quot; str(tem) #&gt; &#39;data.frame&#39;: 1 obs. of 7 variables: #&gt; $ success: logi TRUE #&gt; $ code : chr &quot;1000&quot; #&gt; $ message: chr &quot;요청을 성공적으로 처리하였습니다.&quot; #&gt; $ lang : chr &quot;ko&quot; #&gt; $ country: chr &quot;KR&quot; #&gt; $ result :&#39;data.frame&#39;: 1 obs. of 10 variables: #&gt; ..$ sort : chr &quot;FAVORITE&quot; #&gt; ..$ graph :&#39;data.frame&#39;: 1 obs. of 3 variables: #&gt; .. ..$ gender:&#39;data.frame&#39;: 1 obs. of 2 variables: #&gt; .. .. ..$ male : int 73 #&gt; .. .. ..$ female: int 27 #&gt; .. ..$ old :List of 1 #&gt; .. .. ..$ :&#39;data.frame&#39;: 5 obs. of 5 variables: #&gt; .. .. .. ..$ age : chr &quot;10&quot; &quot;20&quot; &quot;30&quot; &quot;40&quot; ... #&gt; .. .. .. ..$ value: int 2 18 33 23 24 #&gt; .. .. .. ..$ type : chr &quot;exact&quot; &quot;exact&quot; &quot;exact&quot; &quot;exact&quot; ... #&gt; .. .. .. ..$ min : logi TRUE FALSE FALSE FALSE FALSE #&gt; .. .. .. ..$ max : logi FALSE FALSE TRUE FALSE FALSE #&gt; .. ..$ empty : logi FALSE #&gt; ..$ count :&#39;data.frame&#39;: 1 obs. of 5 variables: #&gt; .. ..$ comment : int 1135 #&gt; .. ..$ reply : int 522 #&gt; .. ..$ exposeCount : int 1193 #&gt; .. ..$ delCommentByUser: int 411 #&gt; .. ..$ total : int 1657 #&gt; ..$ config :&#39;data.frame&#39;: 1 obs. of 73 variables: #&gt; .. ..$ useSnsLogin : logi TRUE #&gt; .. ..$ lineFeedOn : logi FALSE #&gt; .. ..$ useBest : logi FALSE #&gt; .. ..$ useVote : logi TRUE #&gt; .. ..$ useVoteSelf : logi FALSE #&gt; .. ..$ useVoteGoodOnly : logi FALSE #&gt; .. ..$ useReport : logi TRUE #&gt; .. ..$ useCommonReport : logi TRUE #&gt; .. ..$ useSort : logi TRUE #&gt; .. ..$ sortTypes :List of 1 #&gt; .. .. ..$ : chr &quot;FAVORITE&quot; &quot;NEW&quot; #&gt; .. ..$ defaultSort : chr &quot;FAVORITE&quot; #&gt; .. ..$ useByteLength : logi FALSE #&gt; .. ..$ useReply : logi TRUE #&gt; .. ..$ useAutoRefresh : logi FALSE #&gt; .. ..$ min : int 1 #&gt; .. ..$ max : int 300 #&gt; .. ..$ useSticker : logi FALSE #&gt; .. ..$ stickerOnly : logi FALSE #&gt; .. ..$ stickerSupportedCategories : logi NA #&gt; .. ..$ stickerDefaultCategory : logi NA #&gt; .. ..$ stickerCategory : logi NA #&gt; .. ..$ stickerContentsUrl : logi NA #&gt; .. ..$ stickerKeyUrl : logi NA #&gt; .. ..$ stickerTabUrl : logi NA #&gt; .. ..$ stickerType : logi NA #&gt; .. ..$ stickerText : logi FALSE #&gt; .. ..$ stickerMarketUrl : logi NA #&gt; .. ..$ stickerMobileResize : logi FALSE #&gt; .. ..$ useProfile : logi FALSE #&gt; .. ..$ profileEmptyImage : logi NA #&gt; .. ..$ displayMaskedUserId : logi FALSE #&gt; .. ..$ useManager : logi FALSE #&gt; .. ..$ managerDelete : logi FALSE #&gt; .. ..$ managerBlock : logi FALSE #&gt; .. ..$ managerNotice : logi FALSE #&gt; .. ..$ contentsManagerIcon : logi FALSE #&gt; .. ..$ secretComment : logi FALSE #&gt; .. ..$ exposureConfig : logi FALSE #&gt; .. ..$ deleteAllAfterBlock : logi FALSE #&gt; .. ..$ useFold : logi TRUE #&gt; .. ..$ replyPreviewCount : int 0 #&gt; .. ..$ maxImageUploadCount : int 0 #&gt; .. ..$ maxImageUploadFileSize : int 0 #&gt; .. ..$ imageAutoRotate : logi FALSE #&gt; .. ..$ autoRefreshTime : int 0 #&gt; .. ..$ autoRefreshDefaultOff : logi FALSE #&gt; .. ..$ autoRefreshChat : logi FALSE #&gt; .. ..$ maxChatFPS : int 0 #&gt; .. ..$ commentModify : logi FALSE #&gt; .. ..$ useCommentModify : logi FALSE #&gt; .. ..$ useViewAll : logi TRUE #&gt; .. ..$ useSnsComment : logi TRUE #&gt; .. ..$ snsCommentDefaultOn : logi TRUE #&gt; .. ..$ useUserLevel : logi FALSE #&gt; .. ..$ useUserBlind : logi FALSE #&gt; .. ..$ maxUserBlindCount : int 0 #&gt; .. ..$ useImageComment : logi FALSE #&gt; .. ..$ useUrlLink : logi FALSE #&gt; .. ..$ useCommentListIncludeDelete: logi FALSE #&gt; .. ..$ useStats : logi TRUE #&gt; .. ..$ useGpopCache : logi FALSE #&gt; .. ..$ useEnterSubmit : logi FALSE #&gt; .. ..$ useListReverse : logi FALSE #&gt; .. ..$ useTranslation : logi FALSE #&gt; .. ..$ useDeletedList : logi TRUE #&gt; .. ..$ useAudio : logi FALSE #&gt; .. ..$ photoInfraUploadDomain : logi NA #&gt; .. ..$ photoInfraSelectDomainHttp : logi NA #&gt; .. ..$ photoInfraSelectDomainHttps: logi NA #&gt; .. ..$ pcTempThumbnailType : chr &quot;ff80_80&quot; #&gt; .. ..$ mobileTempThumbnailType : chr &quot;ff50_50&quot; #&gt; .. ..$ realnameVerificationBlock : logi FALSE #&gt; .. ..$ realnameVerificationMessage: logi NA #&gt; ..$ exposureConfig:&#39;data.frame&#39;: 1 obs. of 2 variables: #&gt; .. ..$ reason: logi NA #&gt; .. ..$ status: chr &quot;COMMENT_ON&quot; #&gt; ..$ bestList :List of 1 #&gt; .. ..$ : list() #&gt; ..$ notice :&#39;data.frame&#39;: 1 obs. of 4 variables: #&gt; .. ..$ noticeNo: int 11 #&gt; .. ..$ title : chr &quot;공직선거법에 따른 댓글작성 제한 안내&quot; #&gt; .. ..$ content : chr &quot;안녕하세요, 네이버 뉴스입니다.\\r&lt;br&gt; \\r&lt;br&gt;공직선거법 제82조 6에 따라 선거운동기간 동안 \\r&lt;br&gt;선거 페이지에 반영된 기사 및 일부&quot;| __truncated__ #&gt; .. ..$ regTime : chr &quot;2017-04-17T01:33:45+0900&quot; #&gt; ..$ userInfo :&#39;data.frame&#39;: 1 obs. of 0 variables #&gt; ..$ pageModel :&#39;data.frame&#39;: 1 obs. of 16 variables: #&gt; .. ..$ page : int 1 #&gt; .. ..$ pageSize : int 10 #&gt; .. ..$ indexSize : int 10 #&gt; .. ..$ startRow : int 1 #&gt; .. ..$ endRow : int 10 #&gt; .. ..$ totalRows : int 1135 #&gt; .. ..$ startIndex : int 0 #&gt; .. ..$ totalPages : int 114 #&gt; .. ..$ firstPage : int 1 #&gt; .. ..$ prevPage : int 0 #&gt; .. ..$ nextPage : int 2 #&gt; .. ..$ lastPage : int 10 #&gt; .. ..$ current : logi NA #&gt; .. ..$ moveToLastPage: logi FALSE #&gt; .. ..$ moveToComment : logi FALSE #&gt; .. ..$ moveToLastPrev: logi FALSE #&gt; ..$ commentList :List of 1 #&gt; .. ..$ :&#39;data.frame&#39;: 10 obs. of 65 variables: #&gt; .. .. ..$ ticket : chr &quot;news&quot; &quot;news&quot; &quot;news&quot; &quot;news&quot; ... #&gt; .. .. ..$ objectId : chr &quot;news437,0000152054&quot; &quot;news437,0000152054&quot; &quot;news437,0000152054&quot; &quot;news437,0000152054&quot; ... #&gt; .. .. ..$ categoryId : chr &quot;*&quot; &quot;*&quot; &quot;*&quot; &quot;*&quot; ... #&gt; .. .. ..$ templateId : chr &quot;default&quot; &quot;view&quot; &quot;view&quot; &quot;view_politics&quot; ... #&gt; .. .. ..$ commentNo : int 895990872 895990402 895994572 895993542 895994142 895995292 895997652 895994952 895990032 895994472 #&gt; .. .. ..$ parentCommentNo : int 895990872 895990402 895994572 895993542 895994142 895995292 895997652 895994952 895990032 895994472 #&gt; .. .. ..$ replyLevel : int 1 1 1 1 1 1 1 1 1 1 #&gt; .. .. ..$ replyCount : int 48 32 14 27 6 3 0 1 10 3 #&gt; .. .. ..$ replyPreviewNo : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ replyList : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ imageCount : int 0 0 0 0 0 0 0 0 0 0 #&gt; .. .. ..$ imageList : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ imagePathList : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ imageWidthList : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ imageHeightList : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ commentType : chr &quot;txt&quot; &quot;txt&quot; &quot;txt&quot; &quot;txt&quot; ... #&gt; .. .. ..$ stickerId : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ sticker : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ sortValue : num 1.49e+12 1.49e+12 1.49e+12 1.49e+12 1.49e+12 ... #&gt; .. .. ..$ contents : chr &quot;국회의원에게 권력을 나눠주느니 차라리 대통령중심제 해라. 각당 원내대표들이 돌아가며 총리 해먹는 꼴 못본다&quot; &quot;4년 중임제가 답이다&quot; &quot;대통령제하에서도 지금 이렇게 난장판을 만들고 있는 국개의원들에게 나라를 맡기라고요? 농담이겠지~ 사사건건 대통령이 일 못하게 방&quot;| __truncated__ &quot;의원내각제는 진짜로 박지원 상왕 만들자는 개헌이지&quot; ... #&gt; .. .. ..$ userIdNo : chr &quot;oCJq&quot; &quot;5qcIZ&quot; &quot;6mKW&quot; &quot;9oKyX&quot; ... #&gt; .. .. ..$ lang : chr &quot;ko&quot; &quot;ko&quot; &quot;ko&quot; &quot;ko&quot; ... #&gt; .. .. ..$ country : chr &quot;KR&quot; &quot;KR&quot; &quot;KR&quot; &quot;KR&quot; ... #&gt; .. .. ..$ idType : chr &quot;naver&quot; &quot;naver&quot; &quot;naver&quot; &quot;naver&quot; ... #&gt; .. .. ..$ idProvider : chr &quot;naver&quot; &quot;naver&quot; &quot;naver&quot; &quot;naver&quot; ... #&gt; .. .. ..$ userName : chr &quot;ssan****&quot; &quot;zamp****&quot; &quot;yhan****&quot; &quot;tjto****&quot; ... #&gt; .. .. ..$ userProfileImage: chr &quot;http://profile.phinf.naver.net/47661/c2300c203d789c4761cb7256042c54e1434afc037bc9e510593d610b89108090.jpg&quot; &quot;http://profile.phinf.naver.net/27148/f77ca3b0a86973c627361a946e9ae3a198c8557fd608f07ead8df1f060808693.jpg&quot; &quot;http://profile.phinf.naver.net/45703/ba160172fc0d0e4a1b3e3c71fb92811a65220334ed0a3d80cabe21b205e13951.jpg&quot; &quot;http://profile.phinf.naver.net/43378/842d4ba6140c89c75e27abf1f0a48910de3c4f95bac6fe9e7347cbbf831e6f42.jpg&quot; ... #&gt; .. .. ..$ profileType : chr &quot;naver&quot; &quot;naver&quot; &quot;naver&quot; &quot;naver&quot; ... #&gt; .. .. ..$ modTime : chr &quot;2017-04-12T21:00:55+0900&quot; &quot;2017-04-12T21:00:21+0900&quot; &quot;2017-04-12T21:05:58+0900&quot; &quot;2017-04-12T21:04:44+0900&quot; ... #&gt; .. .. ..$ modTimeGmt : chr &quot;2017-04-12T12:00:55+0000&quot; &quot;2017-04-12T12:00:21+0000&quot; &quot;2017-04-12T12:05:58+0000&quot; &quot;2017-04-12T12:04:44+0000&quot; ... #&gt; .. .. ..$ regTime : chr &quot;2017-04-12T21:00:55+0900&quot; &quot;2017-04-12T21:00:21+0900&quot; &quot;2017-04-12T21:05:58+0900&quot; &quot;2017-04-12T21:04:44+0900&quot; ... #&gt; .. .. ..$ regTimeGmt : chr &quot;2017-04-12T12:00:55+0000&quot; &quot;2017-04-12T12:00:21+0000&quot; &quot;2017-04-12T12:05:58+0000&quot; &quot;2017-04-12T12:04:44+0000&quot; ... #&gt; .. .. ..$ sympathyCount : int 2358 1907 1642 1914 644 493 470 428 466 418 #&gt; .. .. ..$ antipathyCount : int 70 100 38 152 37 11 5 10 34 23 #&gt; .. .. ..$ userBlind : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ hideReplyButton : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ status : int 0 0 0 0 0 0 0 0 0 0 #&gt; .. .. ..$ mine : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ best : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ mentions : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ userStatus : int 0 0 0 0 0 0 0 0 0 0 #&gt; .. .. ..$ categoryImage : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ open : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ levelCode : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ sympathy : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ antipathy : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ snsList : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ metaInfo : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ extension : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ audioInfoList : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ translation : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ visible : logi TRUE TRUE TRUE TRUE TRUE TRUE ... #&gt; .. .. ..$ manager : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ deleted : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ shardTableNo : int 144 144 144 144 144 144 144 144 144 144 #&gt; .. .. ..$ blind : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ secret : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ expose : logi TRUE TRUE TRUE TRUE TRUE TRUE ... #&gt; .. .. ..$ profileUserId : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ containText : logi TRUE TRUE TRUE TRUE TRUE TRUE ... #&gt; .. .. ..$ validateBanWords: logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ maskedUserId : chr &quot;ssan****&quot; &quot;zamp****&quot; &quot;yhan****&quot; &quot;tjto****&quot; ... #&gt; .. .. ..$ maskedUserName : chr &quot;ss****&quot; &quot;za****&quot; &quot;yh****&quot; &quot;tj****&quot; ... #&gt; .. .. ..$ exposeByCountry : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ virtual : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; $ date : chr &quot;2017-04-20T09:35:35+0000&quot; JSON을 전문적으로 다루기 위한 패키지도 있으니 확인해 보세요. 2.5.2 리스트의 일부 데이터 불러오기 이제 list에서 일부 데이터를 불러오는 실습을 해보겠습니다. 다른 자료형처럼 데이터의 일부를 불러오는 방법과 이름을 사용하는 방법, [[ ]]를 사용하고, $ + 데이터의 이름을 사용하는 방법들이 있습니다. similar_song &lt;- list(title = &quot;R you on time?&quot;, duration = 230) song &lt;- list(title = &quot;Rsome times&quot;, duration = 190, track = 5, similar = similar_song) song #&gt; $title #&gt; [1] &quot;Rsome times&quot; #&gt; #&gt; $duration #&gt; [1] 190 #&gt; #&gt; $track #&gt; [1] 5 #&gt; #&gt; $similar #&gt; $similar$title #&gt; [1] &quot;R you on time?&quot; #&gt; #&gt; $similar$duration #&gt; [1] 230 song[1] #&gt; $title #&gt; [1] &quot;Rsome times&quot; song[[1]] #&gt; [1] &quot;Rsome times&quot; song[c(1, 3)] #&gt; $title #&gt; [1] &quot;Rsome times&quot; #&gt; #&gt; $track #&gt; [1] 5 &gt; song[[c(1, 3)]] ## Error in song[[c(1, 3)]] : subscript out of bounds &gt; song[[1]][[3]] ## Error in song[[1]][[3]] : subscript out of bounds devtools::install_github(“forkonlp/N2H4”) song[[3]][[1]] #&gt; [1] 5 song[[c(4, 1)]] #&gt; [1] &quot;R you on time?&quot; song[[&quot;duration&quot;]] #&gt; [1] 190 song[&quot;duration&quot;] #&gt; $duration #&gt; [1] 190 song[c(&quot;duration&quot;, &quot;similar&quot;)] #&gt; $duration #&gt; [1] 190 #&gt; #&gt; $similar #&gt; $similar$title #&gt; [1] &quot;R you on time?&quot; #&gt; #&gt; $similar$duration #&gt; [1] 230 song$duration #&gt; [1] 190 friends &lt;- c(&quot;Kurt&quot;, &quot;Florence&quot;, &quot;Patti&quot;, &quot;Dave&quot;) song$sent &lt;- friends song #&gt; $title #&gt; [1] &quot;Rsome times&quot; #&gt; #&gt; $duration #&gt; [1] 190 #&gt; #&gt; $track #&gt; [1] 5 #&gt; #&gt; $similar #&gt; $similar$title #&gt; [1] &quot;R you on time?&quot; #&gt; #&gt; $similar$duration #&gt; [1] 230 #&gt; #&gt; #&gt; $sent #&gt; [1] &quot;Kurt&quot; &quot;Florence&quot; &quot;Patti&quot; &quot;Dave&quot; song[[&quot;sent&quot;]] &lt;- friends song$similar$reason &lt;- &quot;too long&quot; song #&gt; $title #&gt; [1] &quot;Rsome times&quot; #&gt; #&gt; $duration #&gt; [1] 190 #&gt; #&gt; $track #&gt; [1] 5 #&gt; #&gt; $similar #&gt; $similar$title #&gt; [1] &quot;R you on time?&quot; #&gt; #&gt; $similar$duration #&gt; [1] 230 #&gt; #&gt; $similar$reason #&gt; [1] &quot;too long&quot; #&gt; #&gt; #&gt; $sent #&gt; [1] &quot;Kurt&quot; &quot;Florence&quot; &quot;Patti&quot; &quot;Dave&quot; 2.6 데이터프레임 2.6.1 사람이 이해하기 쉬운 자료형 다양한 형태의 자료형을 묶어서 사용하는 list를 만들고 보니, 반대로 너무 자유도가 높아서 사용하기 어려운 문제들이 나타났습니다. 그렇다 보니 조금 제약사항을 만들어 보기로 합니다. 그렇게 해서 탄생한게 data.frame입니다. 기존에 알고 계시는 엑셀 시트나 설문조사를 정리한 표 같은 걸 생각하시면 도움이 되실 겁니다. data.frame은 list와 달리 vector를 각 열로 유지하여 합치는 방식을 사용했습니다. 그래서 하나의 열 내에서는 데이터가 vector와 같이 자료형이 모두 같아야 하고, 하나의 행에서는 자료형이 여러 개가 가능합니다. name &lt;- c(&quot;Anne&quot;, &quot;Pete&quot;, &quot;Frank&quot;, &quot;Julia&quot;, &quot;Cath&quot;) age &lt;- c(28, 30, 21, 39, 35) child &lt;- c(FALSE, TRUE, TRUE, FALSE, TRUE) df &lt;- data.frame(name, age, child) df #&gt; name age child #&gt; 1 Anne 28 FALSE #&gt; 2 Pete 30 TRUE #&gt; 3 Frank 21 TRUE #&gt; 4 Julia 39 FALSE #&gt; 5 Cath 35 TRUE 물론 names도 사용합니다. names는 열의 이름을 뜻합니다. 똑같이 처음부터 지정해 줄수 있구요. 지정하지 않으면 임의로 data.frame이 선정해서 가지고 있습니다. names(df) #&gt; [1] &quot;name&quot; &quot;age&quot; &quot;child&quot; names(df) &lt;- c(&quot;Name&quot;, &quot;Age&quot;, &quot;Child&quot;) df #&gt; Name Age Child #&gt; 1 Anne 28 FALSE #&gt; 2 Pete 30 TRUE #&gt; 3 Frank 21 TRUE #&gt; 4 Julia 39 FALSE #&gt; 5 Cath 35 TRUE df &lt;- data.frame(Name = name, Age = age, Child = child) df #&gt; Name Age Child #&gt; 1 Anne 28 FALSE #&gt; 2 Pete 30 TRUE #&gt; 3 Frank 21 TRUE #&gt; 4 Julia 39 FALSE #&gt; 5 Cath 35 TRUE str(df) #&gt; &#39;data.frame&#39;: 5 obs. of 3 variables: #&gt; $ Name : chr &quot;Anne&quot; &quot;Pete&quot; &quot;Frank&quot; &quot;Julia&quot; ... #&gt; $ Age : num 28 30 21 39 35 #&gt; $ Child: logi FALSE TRUE TRUE FALSE TRUE data.frame은 각 열의 데이터 갯수가 맞지 않으면 만들어 지지 않습니다. &gt; data.frame(name[-1], age, child) ## Error in data.frame(name[-1], age, child) : ## arguments imply differing number of rows: 4, 5 그리고 글자를 모두 factor를 기본 값으로 지정합니다. 그래서 stringsAsFactors 옵션을 FALSE로 해줘야 charater로 데이터를 만들 수 있습니다. stringsAsFactors는 options에서도 지정해서 사용할 수 있습니다. df &lt;- data.frame(name, age, child, stringsAsFactors = FALSE) str(df) #&gt; &#39;data.frame&#39;: 5 obs. of 3 variables: #&gt; $ name : chr &quot;Anne&quot; &quot;Pete&quot; &quot;Frank&quot; &quot;Julia&quot; ... #&gt; $ age : num 28 30 21 39 35 #&gt; $ child: logi FALSE TRUE TRUE FALSE TRUE list와 같이 위치값이나 이름으로 데이터의 일부를 불러올 수 있습니다. name &lt;- c(&quot;Anne&quot;, &quot;Pete&quot;, &quot;Frank&quot;, &quot;Julia&quot;, &quot;Cath&quot;) age &lt;- c(28, 30, 21, 39, 35) child &lt;- c(FALSE, TRUE, TRUE, FALSE, TRUE) people &lt;- data.frame(name, age, child, stringsAsFactors = FALSE) people #&gt; name age child #&gt; 1 Anne 28 FALSE #&gt; 2 Pete 30 TRUE #&gt; 3 Frank 21 TRUE #&gt; 4 Julia 39 FALSE #&gt; 5 Cath 35 TRUE people[3,2] #&gt; [1] 21 people[3,&quot;age&quot;] #&gt; [1] 21 people[3,] #&gt; name age child #&gt; 3 Frank 21 TRUE people[,&quot;age&quot;] #&gt; [1] 28 30 21 39 35 people[c(3, 5), c(&quot;age&quot;, &quot;child&quot;)] #&gt; age child #&gt; 3 21 TRUE #&gt; 5 35 TRUE people[2] #&gt; age #&gt; 1 28 #&gt; 2 30 #&gt; 3 21 #&gt; 4 39 #&gt; 5 35 people$age #&gt; [1] 28 30 21 39 35 people[[&quot;age&quot;]] #&gt; [1] 28 30 21 39 35 people[[2]] #&gt; [1] 28 30 21 39 35 people[&quot;age&quot;] #&gt; age #&gt; 1 28 #&gt; 2 30 #&gt; 3 21 #&gt; 4 39 #&gt; 5 35 people[2] #&gt; age #&gt; 1 28 #&gt; 2 30 #&gt; 3 21 #&gt; 4 39 #&gt; 5 35 data.frame은 데이터를 추가하는 여러 가지 방법을 지원합니다. 이전에 한번씩 본 방식이니 테스트해보세요. height &lt;- c(163, 177, 163, 162, 157) people$height &lt;- height people[[&quot;height&quot;]] &lt;- height people #&gt; name age child height #&gt; 1 Anne 28 FALSE 163 #&gt; 2 Pete 30 TRUE 177 #&gt; 3 Frank 21 TRUE 163 #&gt; 4 Julia 39 FALSE 162 #&gt; 5 Cath 35 TRUE 157 weight &lt;- c(74, 63, 68, 55, 56) cbind(people, weight) #&gt; name age child height weight #&gt; 1 Anne 28 FALSE 163 74 #&gt; 2 Pete 30 TRUE 177 63 #&gt; 3 Frank 21 TRUE 163 68 #&gt; 4 Julia 39 FALSE 162 55 #&gt; 5 Cath 35 TRUE 157 56 &gt; tom &lt;- data.frame(&quot;Tom&quot;, 37, FALSE, 183) &gt; rbind(people, tom) ## Error in match.names(clabs, names(xi)) : ## names do not match previous names tom &lt;- data.frame(name = &quot;Tom&quot;, age = 37, child = FALSE, height = 183) rbind(people, tom) #&gt; name age child height #&gt; 1 Anne 28 FALSE 163 #&gt; 2 Pete 30 TRUE 177 #&gt; 3 Frank 21 TRUE 163 #&gt; 4 Julia 39 FALSE 162 #&gt; 5 Cath 35 TRUE 157 #&gt; 6 Tom 37 FALSE 183 2.6.2 순서에 대해 작업하기 순서는 data.frame뿐만 아니라 다른 자료형에서도 그대로 적용되는 내용입니다. 여기서는 sort와 order에 대해서 알아보겠습니다. sort(people$age) #&gt; [1] 21 28 30 35 39 ranks &lt;- order(people$age) ranks #&gt; [1] 3 1 2 5 4 people$age #&gt; [1] 28 30 21 39 35 ranks &lt;- order(people$age) ranks #&gt; [1] 3 1 2 5 4 people[ranks, ] #&gt; name age child height #&gt; 3 Frank 21 TRUE 163 #&gt; 1 Anne 28 FALSE 163 #&gt; 2 Pete 30 TRUE 177 #&gt; 5 Cath 35 TRUE 157 #&gt; 4 Julia 39 FALSE 162 people[order(people$age, decreasing = TRUE), ] #&gt; name age child height #&gt; 4 Julia 39 FALSE 162 #&gt; 5 Cath 35 TRUE 157 #&gt; 2 Pete 30 TRUE 177 #&gt; 1 Anne 28 FALSE 163 #&gt; 3 Frank 21 TRUE 163 sort는 순서가 있는 데이터(지금의 예시로는 나이)를 오름차순으로 정렬해줍니다. 글자라면 알파벳순으로 정렬해 줄 것입니다. 한 번 실험해 보세요. order는 그 위치에 있는 데이터가 전체 데이터 내에서 몇 번째에 위치하는지를 알려줍니다. sort가 정렬이 끝난 결과를 보여주는 것이라면 order는 그 데이터의 순서값 자체를 보여주는 것이죠. 그렇기 때문에 order는 [ ]의 행부분 조건과 결합하여 많이 사용됩니다. 2.7 날짜 날짜는 어느 곳에서든 다루기 어려운 데이터입니다. 불규칙적인 윤달이라던지 하는 여러 가지 문제로 실제로 사용할 때 많은 문제가 있는데요, R에서는 여러 형태의 날짜를 표현하는 데이터를 Date라는 자료형으로 관리하고 있습니다. 사람들이 관행적으로 사용하는 형태의 character 날짜를 Date형으로 바꿔보겠습니다. dates &lt;- c(&quot;2016/01/01&quot;,&quot;2016/02/01&quot;,&quot;2016/03/01&quot;,&quot;2016/04/01&quot;,&quot;2016/05/01&quot;,&quot;2016/06/01&quot;) dates #&gt; [1] &quot;2016/01/01&quot; &quot;2016/02/01&quot; &quot;2016/03/01&quot; &quot;2016/04/01&quot; &quot;2016/05/01&quot; #&gt; [6] &quot;2016/06/01&quot; class(dates) #&gt; [1] &quot;character&quot; trans.dates &lt;- as.Date(dates) trans.dates #&gt; [1] &quot;2016-01-01&quot; &quot;2016-02-01&quot; &quot;2016-03-01&quot; &quot;2016-04-01&quot; &quot;2016-05-01&quot; #&gt; [6] &quot;2016-06-01&quot; class(trans.dates) #&gt; [1] &quot;Date&quot; Date형 일때의 장점은 계산이 가능하다는 것입니다. trans.dates[3]-trans.dates[1] #&gt; Time difference of 60 days 다른 모양의 character도 되는지 한번 보겠습니다. dates2 &lt;- c(&quot;2016-01-01&quot;,&quot;2016-02-01&quot;,&quot;2016-03-01&quot;,&quot;2016-04-01&quot;,&quot;2016-05-01&quot;,&quot;2016-06-01&quot;) trans.dates2 &lt;- as.Date(dates2) trans.dates2 #&gt; [1] &quot;2016-01-01&quot; &quot;2016-02-01&quot; &quot;2016-03-01&quot; &quot;2016-04-01&quot; &quot;2016-05-01&quot; #&gt; [6] &quot;2016-06-01&quot; class(trans.dates2) #&gt; [1] &quot;Date&quot; 어려운 모양은 인식하지 못합니다. 그래서 일부러 양식을 알려주면 R이 고칠 수 있는데요. &gt; as.Date(&quot;2016년 4월 5일&quot;) ## Error in charToDate(x) : 문자열이 표준서식을 따르지 않습니다 as.Date(&quot;2016년 4월 5일&quot;, format=&quot;%Y년 %m월 %d일&quot;) #&gt; [1] &quot;2016-04-05&quot; 양식은 저도 다 외우지 못하고 매번 검색해서 사용합니다. http://www.stat.berkeley.edu/classes/s133/dates.html 하지만 year의 y(4자 Y, 2자 y), month의 m, day의 d 로 생각하시면 우선 해결되고 나머지는 위에 링크를 참고해 보시면 좋을 것 같습니다. as.Date(34519, origin=&quot;1900-01-01&quot;) #&gt; [1] &quot;1994-07-06&quot; 시간은 POSIXct와 POSIXlt 두 가지로 준비되어 있습니다. 분석에 적용하는데 있어 특별히 구분해서 사용하지 않아서, 하나를 선택하셨다면 일관되게 한 가지만 계속 사용하시면 좋을 것 같습니다. # 시간 자료형 as.POSIXct(&quot;2017-04-12 12:00:00&quot;) #&gt; [1] &quot;2017-04-12 12:00:00 UTC&quot; as.POSIXlt(&quot;2017-04-12 12:00:00&quot;) #&gt; [1] &quot;2017-04-12 12:00:00 UTC&quot; 날짜와 시간을 다루는 패키지로 유명한 lubridate가 있습니다. 아래 여러 코드의 실행결과를 보시면 그 유연한 기능에 감탄하시게 될 겁니다. library(lubridate) #&gt; Loading required package: methods #&gt; #&gt; Attaching package: &#39;lubridate&#39; #&gt; The following object is masked from &#39;package:base&#39;: #&gt; #&gt; date ymd(&quot;2017-05-05&quot;) #&gt; [1] &quot;2017-05-05&quot; ymd(&quot;170505&quot;) #&gt; [1] &quot;2017-05-05&quot; ymd(&quot;20170505&quot;) #&gt; [1] &quot;2017-05-05&quot; dmy(&quot;17-05-15&quot;) #&gt; [1] &quot;2015-05-17&quot; ymd(&quot;2017년 5월 5일&quot;) #&gt; [1] &quot;2017-05-05&quot; dmy(&quot;5일5월2017년&quot;) #&gt; [1] &quot;2017-05-05&quot; dates &lt;- c(&quot;2017-05-05&quot;,&quot;170505&quot;,&quot;20170505&quot;,&quot;17-05-15&quot;,&quot;2017년 5월 5일&quot;) ymd(dates) #&gt; [1] &quot;2017-05-05&quot; &quot;2017-05-05&quot; &quot;2017-05-05&quot; &quot;2017-05-15&quot; &quot;2017-05-05&quot; data &lt;- ymd(&quot;2017-05-05&quot;) data #&gt; [1] &quot;2017-05-05&quot; year(data) #&gt; [1] 2017 month(data) #&gt; [1] 5 month(data, label=T) #&gt; [1] May #&gt; 12 Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; ... &lt; Dec week(data) #&gt; [1] 18 yday(data) #&gt; [1] 125 mday(data) #&gt; [1] 5 wday(data) #&gt; [1] 6 wday(data, label=T) #&gt; [1] Fri #&gt; Levels: Sun &lt; Mon &lt; Tues &lt; Wed &lt; Thurs &lt; Fri &lt; Sat "],
["for-apply.html", "3 단순 반복 업무를 위한 for문과 apply류 맛보기 3.1 조건문 3.2 반복문 3.3 apply류의 함수들", " 3 단순 반복 업무를 위한 for문과 apply류 맛보기 3.1 조건문 3.1.1 if if는 if (조건) {조건이 true 이면 실행할 부분}으로 구성됩니다. if(TRUE){print(1)} #&gt; [1] 1 print(2) #&gt; [1] 2 조건은 결과가 하나의 logical 값으로 나와야 하고 여러 개의 logical 값이면 맨 앞의 값만 사용한다는 warning을 같이 출력합니다. if(c(T,F,F,F)){print(1)} #&gt; Warning in if (c(T, F, F, F)) {: the condition has length &gt; 1 and only the #&gt; first element will be used #&gt; [1] 1 print(2) #&gt; [1] 2 보통은 아래와 같은 형식으로 사용합니다. x&lt;-1 if ( x &gt; 0 ){ print(1) } 이제까지 조건이라고 말하는 것이 있었는데, 조건이란 TRUE, FALSE로 결과가 나오는 표현 전부를 뜻합니다. 제가 if문에서 나올 만한 예시를 준비했습니다. x&lt;-c() if(identical(x,c())){print(&quot;x has no data.&quot;)} #&gt; [1] &quot;x has no data.&quot; print(&quot;if part done.&quot;) #&gt; [1] &quot;if part done.&quot; options(stringsAsFactors = F) y&lt;-c(1,2,3) z&lt;-c(1,2,3) if(length(y)==length(z)){ tem&lt;-data.frame(y,z) print(tem) } #&gt; y z #&gt; 1 1 1 #&gt; 2 2 2 #&gt; 3 3 3 print(&quot;if part done.&quot;) #&gt; [1] &quot;if part done.&quot; identical은 두 개의 변수를 비교해주고 같으면 TRUE, 다르면 FALSE를 결과로 주는 함수입니다. 결과를 logical로 주는 덕분에 조건문에 사용하기 딱 좋은 함수 입니다. 예를 들어 데이터에 무언가 문제가 생겨서 함수에 들어가지 못하거나 할때 우회하는 조건을 작성하는데 좋습니다. 저같은 경우는 N2H4 패키지를 작성할 때 getContent에서 사용했습니다. 물론 이상적으로는 정규식과 네이버 뉴스의 root url을 바탕으로 비교하는 식으로 해야 더 정교하겠습니다만, getUrlListByCategory 함수에서 생성되는 link를 사용하는 형태도 구성되어 있어서 아래와 같이 작성하였습니다. ... if(!identical(url,character(0))){ if (RCurl::url.exists(url)&amp; &quot;error_msg 404&quot;!=(read_html(url)%&gt;%html_nodes(&quot;div#main_content div div&quot;)%&gt;%html_attr(&quot;class&quot;))[1] ) { ... 3.1.2 else 영어 표현을 보면 생각하기 쉬우시겠지만 if(조건){조건이 true 이면 실행할 부분} 이후에 사용해서 조건이 false면 실행할 부분을 작성하는데 사용합니다. if (조건) {조건이 true 이면 실행할 부분} else {조건이 false 면 실행할 부분}으로 구성됩니다. if(TRUE){ print(1) } else { print(3) } #&gt; [1] 1 print(2) #&gt; [1] 2 else는 앞에 if가 조건을 작성했기 때문에 추가적인 조건을 작성하지는 않습니다. 여러 if 조건을 사용하고 그 이후에 else를 사용할 수도 있습니다. x&lt;-1 if(x&lt;0){ print(1) } if(x&gt;10) { print(3) } else { print(2) } #&gt; [1] 2 print(4) #&gt; [1] 4 최근의 코드 작성 스타일은 누가 봐도 읽고 이해하기 쉽게 이다 보니 고려하면 좋을 것 같습니다. 특히 이 스타일은 자기 자신에게도 적용이 되어서, 나중에 봐도 기억하기 쉽게 작성하는 것이 좋습니다. 3.1.3 ifelse ifelse는 앞에 함수와는 다른 결과를 제공해서 사용하는 곳이 다릅니다. 우선 형태는 ifelse(조건, 조건이 true일때 할 것, 조건이 false일때 할 것)으로 구성됩니다. 그래서 기존의 데이터를 새로운 기준으로 조정해서 사용할 때 많이 사용합니다. library(readr) sd&lt;-read_csv(&quot;./제3회 Big Data Competition-분석용데이터-05.멤버십여부.txt&quot;) #&gt; Parsed with column specification: #&gt; cols( #&gt; 고객번호 = col_character(), #&gt; 멤버십명 = col_character(), #&gt; 가입년월 = col_integer() #&gt; ) names(sd)[1]&lt;-&quot;고객번호&quot; sd&lt;-data.frame(sd) str(sd) #&gt; &#39;data.frame&#39;: 7456 obs. of 3 variables: #&gt; $ 고객번호: chr &quot;00011&quot; &quot;00021&quot; &quot;00037&quot; &quot;00043&quot; ... #&gt; $ 멤버십명: chr &quot;하이마트&quot; &quot;하이마트&quot; &quot;하이마트&quot; &quot;하이마트&quot; ... #&gt; $ 가입년월: int 201512 201506 201306 201403 201411 201312 201506 201404 201406 201311 ... summary(sd) #&gt; 고객번호 멤버십명 가입년월 #&gt; Length:7456 Length:7456 Min. :201210 #&gt; Class :character Class :character 1st Qu.:201311 #&gt; Mode :character Mode :character Median :201407 #&gt; Mean :201412 #&gt; 3rd Qu.:201504 #&gt; Max. :201512 sd$&quot;최근고객&quot;&lt;-ifelse(sd$&quot;가입년월&quot;&gt;mean(sd$&quot;가입년월&quot;),&quot;최근&quot;,&quot;최근아님&quot;) head(sd) #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 1 00011 하이마트 201512 최근 #&gt; 2 00021 하이마트 201506 최근 #&gt; 3 00037 하이마트 201306 최근아님 #&gt; 4 00043 하이마트 201403 최근아님 #&gt; 5 00044 하이마트 201411 최근아님 #&gt; 6 00061 하이마트 201312 최근아님 관련해서 여기를 가보시면 for문에 대한 간략한 방법을 질문하시고, 댓글로 여러 답변이 달렸는데, ifelse가 가장 좋은 해결책으로 보입니다. 확인해보세요. 3.1.4 try try는 error를 우회하거나 활용하기 위해서 사용하는 함수입니다. 직접 사용할 일은 많지 않지만 함수의 실행에서 에러가 났을 때 (ex&gt; data.frame은 데이터의 길이가 다르면 변수를 만들지 못하고 에러를 출력합니다.) 에러가 난 부분만 기록하고 넘기는 형태로 코드를 작성 할 수 있습니다. 더 섬세하 기능의 tryCatch 도 있으니 ?tryCatch를 확인해주세요. noObj print(1) ## Error in try(noObj) : object &#39;noObj&#39; not found try(noObj) print(1) #&gt; [1] 1 콘솔에서 실행하면 try(noObj)에서 에러가 발생합니다. 하지만 멈추는 것이 아니라 다음 코드를 실행하는 것이 그냥 noObj를 코드에 작성한 것과 차이점입니다. try를 입력해 보시면 silect 옵션이 있는데 TRUE로 해주면 에러 출력도 하지 않습니다. err&lt;-try(noObj) err #&gt; [1] &quot;Error in try(noObj) : object &#39;noObj&#39; not found\\n&quot; #&gt; attr(,&quot;class&quot;) #&gt; [1] &quot;try-error&quot; #&gt; attr(,&quot;condition&quot;) #&gt; &lt;simpleError in doTryCatch(return(expr), name, parentenv, handler): object &#39;noObj&#39; not found&gt; class(err) #&gt; [1] &quot;try-error&quot; 위와 같은 식으로 try(함수)를 변수에 선언하면 class(변수)를 통해 조건문을 활용해서 에러가 발생했을 때를 직접적으로 우회할 수 있습니다. 3.2 반복문 3.2.1 repeat repeat은 가장 단순한 형태의 반복 구분입니다. 그냥 repeat만 사용할 수도 있습니다만, repeat(print(1))을 실행하면 무한히 1을 출력하고 멈추지 않습니다. 강제로 멈추는 활동을 해주어야만 멈추니 주의해 주세요. 그래서 break 문법이 준비되어 있습니다. 3.2.2 break break는 말 그대로 멈추라는 명령입니다. break는 독특하게 뒤에 ()를 붙이지 않고 활용하는 함수로 조건문이나 반복문 안에 쓰여서 조건문과 반복문을 멈추는 역할을 합니다. x&lt;-1 repeat( if(x&gt;10){ break } else { print(x) x&lt;-x+1 } ) #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 #&gt; [1] 6 #&gt; [1] 7 #&gt; [1] 8 #&gt; [1] 9 #&gt; [1] 10 3.2.3 while 사실 repeat문은 사용법이 조금 길이서 잘 사용하지 않습니다. 기능적인 대체는 while문으로 가능한데, while은 while(조건){조건이 true인 동안 할 것}으로 구성됩니다. x&lt;-1 while(x&lt;10){ print(x) x&lt;-x+1 } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 #&gt; [1] 6 #&gt; [1] 7 #&gt; [1] 8 #&gt; [1] 9 위의 코드가 아까 repeat으로 만든 식과 같은 결과를 보여줍니다. 안의 조건이 달라서 이해가 어려우실 수 있어서 repeat을 다시 작성해보겠습니다. x&lt;-1 repeat( if(x&lt;10){ print(x) x&lt;-x+1 } else { break } ) #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 #&gt; [1] 6 #&gt; [1] 7 #&gt; [1] 8 #&gt; [1] 9 자유도가 높은 repeat에 비해서 while은 괄고 안의 조건이 TRUE일 때 동안만 동작합니다. 하지만 한 방법으로만 고정되어 있어서 오히려 혼란을 막고, 코드가 읽기 좋게 작성할 수 있는 장점이 있습니다. 3.2.4 for for는 반복하는 내용을 쉽게 다루기 위해서 준비되어 있습니다. 예를 들어서 위에서 while로 작성된 것을 for로 다시 작성해 보겠습니다. for(x in 1:9){ print(x) } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 #&gt; [1] 6 #&gt; [1] 7 #&gt; [1] 8 #&gt; [1] 9 while에 비해 훨씬 간결해 졌습니다. 이해하기도 좋구요. for(반복에 사용할 변수 in 반복에 사용할 변수에 넣을 데이터를 가지는 벡터){반복 실행할 내용 - 반복에 사용할 변수를 활용함}의 형태로 사용합니다. 말로 풀어 쓰려니 오히려 어려워 보이는 것 같네요. 몇 가지 예시를 더 들어 보겠습니다. data&lt;-head(sd$&quot;고객번호&quot;) for(cNum in data){ print(sd[sd$&quot;고객번호&quot;==cNum,]) } #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 1 00011 하이마트 201512 최근 #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 2 00021 하이마트 201506 최근 #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 3 00037 하이마트 201306 최근아님 #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 4 00043 하이마트 201403 최근아님 #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 5 00044 하이마트 201411 최근아님 #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 6 00061 하이마트 201312 최근아님 N2H4의 사용예시도 복잡하게 무려 5중 for문(!)으로 구성되어 있습니다. 중간에 while, try, if도 다 사용되었으니 설명해 드리겠습니다. 3.2.5 next 에러에 대해 우회하는 것에 대해서 조건문을 주는 방법을 설명드렸었습니다. next는 break와 비슷하지만 조건문이나 반복문을 멈추는 것이 아니라 다음 번으로 넘기는 역할을 합니다. 예를 들면 아래와 같습니다. data&lt;-head(sd$&quot;고객번호&quot;) for(cNum in data){ if(sd[sd$&quot;고객번호&quot;==cNum,&quot;최근고객&quot;]==&quot;최근&quot;){next} print(sd[sd$&quot;고객번호&quot;==cNum,]) } #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 3 00037 하이마트 201306 최근아님 #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 4 00043 하이마트 201403 최근아님 #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 5 00044 하이마트 201411 최근아님 #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 6 00061 하이마트 201312 최근아님 출력된 내용을 보면 sd[sd$&quot;고객번호&quot;==cNum,&quot;최근고객&quot;]==&quot;최근&quot;일 때 다음 줄에 있는 print를 하지 않고 다음(next)으로 넘어간 것을 확인할 수 있습니다. 이걸 통해서 조건에 따라 그 아래 내용을 실행하지 않고 다음번 반복으로 넘기는 것이 가능합니다. N2H4의 사용예시에는 next를 사용하지 않고 while을 사용했는데, 크롤링 특성상 요청이 일부 실패도 할 수 있기 때문에 추가적인 시도를 하기 위해서 사용했습니다. 데이터를 전부 가져오는 것이 많이 중요하지 않다면 next를 사용하는 것이 더 간편하고 빠르게 작성하는 방법이 될 것 같습니다. 지금 예시를 눈으로 보여드리기 위해 for문 안을 print로 계속 채우고 있는데, print의 위치에 수행하고자 하는 함수를 작성하시면 됩니다. X&lt;-as.data.frame(matrix(1:64, ncol=4, dimnames=list(seq(1:16), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)))) X$a[c(1,3,10)]&lt;-0 for (i in 1:nrow(X)){ if (X$a[i]==0) { X$e[i]&lt;-(-999) } else { X$e[i]&lt;-X$b[i]/X$c[i] } } X #&gt; a b c d e #&gt; 1 0 17 33 49 -999.000 #&gt; 2 2 18 34 50 0.529 #&gt; 3 0 19 35 51 -999.000 #&gt; 4 4 20 36 52 0.556 #&gt; 5 5 21 37 53 0.568 #&gt; 6 6 22 38 54 0.579 #&gt; 7 7 23 39 55 0.590 #&gt; 8 8 24 40 56 0.600 #&gt; 9 9 25 41 57 0.610 #&gt; 10 0 26 42 58 -999.000 #&gt; 11 11 27 43 59 0.628 #&gt; 12 12 28 44 60 0.636 #&gt; 13 13 29 45 61 0.644 #&gt; 14 14 30 46 62 0.652 #&gt; 15 15 31 47 63 0.660 #&gt; 16 16 32 48 64 0.667 ifelse 함수에서 소개했던 질문쪽의 for로 작성된 코드입니다. for로 작성하는 것이 사실 생각하기 쉬운 방법이라고 생각합니다. 저는 심지어 처음에는 for로 작성하라고 권장합니다. 문제를 직접 겪고, 그 문제를 해결하는 방법을 찾으려할 때 그 방법이 더 몸에 남는 것 같습니다. 아래 apply를 하기 전에 for와 ifelse가 얼마나 다른지 한 번 비교해 보겠습니다. library(ggplot2) library(dplyr) #&gt; #&gt; Attaching package: &#39;dplyr&#39; #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; filter, lag #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; intersect, setdiff, setequal, union library(tidyr) times&lt;-c(100,1000,10000,30000,50000,100000) tData&lt;-c() for(tm in times){ X&lt;-as.data.frame(matrix(1:tm, ncol=4, dimnames=list(seq(1:(tm/4)), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)))) X$a[c(1,3,10)]&lt;-0 forTime&lt;-system.time( for (i in 1:nrow(X)){ if (X$a[i]==0) { X$e[i]&lt;-(-999) } else { X$e[i]&lt;-X$b[i]/X$c[i] } } ) ifelseTime&lt;-system.time(X$e &lt;- ifelse(X$a == 0, -999, X$b/X$c)) forTime&lt;-cbind(data.frame(tm,cate=&quot;forTime&quot;),t(as.matrix(forTime))) ifelseTime&lt;-cbind(data.frame(tm,cate=&quot;ifelseTime&quot;),t(as.matrix(ifelseTime))) tData&lt;-rbind(tData,forTime,ifelseTime) } tData&lt;-tData %&gt;% select(tm:elapsed) %&gt;% gather(tm,cate) names(tData)&lt;-c(&quot;iter&quot;,&quot;cate&quot;,&quot;timeName&quot;,&quot;time&quot;) ggplot(tData,aes(x=iter,y=time,fill=cate,color=cate)) + geom_point(stat=&quot;identity&quot;) tm&lt;-1000000 X&lt;-as.data.frame(matrix(1:tm, ncol=4, dimnames=list(seq(1:(tm/4)), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)))) ifelseTime&lt;-system.time(X$e &lt;- ifelse(X$a == 0, -999, X$b/X$c)) ifelseTime #&gt; user system elapsed #&gt; 0.020 0.000 0.023 이렇게 for를 사용하지 않고 다른 방법을 사용하는 것으로 벡터연산이 있습니다. 이름이 중요하진 않으니 R이 감당할 수 있는 수준의 데이터를 apply를 통해서 다루는 법을 알아보겠습니다. 3.3 apply류의 함수들 3.3.1 apply apply 함수에 대해서 알아보겠습니다. apply는 행이나 열 방향의 데이터를 한 번에 계산하는데 사용합니다. set.seed(1) ( myMat &lt;- matrix(round(rnorm(16,10),2),4,4) ) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 9.37 10.33 10.58 9.38 #&gt; [2,] 10.18 9.18 9.69 7.79 #&gt; [3,] 9.16 10.49 11.51 11.12 #&gt; [4,] 11.60 10.74 10.39 9.96 위의 mymat에서 각 열의 평균을 구하고 싶으면 이렇게 하면 됩니다. mean(myMat[,1]) #&gt; [1] 10.1 mean(myMat[,2]) #&gt; [1] 10.2 mean(myMat[,3]) #&gt; [1] 10.5 mean(myMat[,4]) #&gt; [1] 9.56 우리는 for를 배웠으니 좀 고쳐 봅시다. for(i in 1:4){ mean(myMat[,i]) } 이게 또 데이터가 따로따로라 c도 해줘야 하는 군요. myMean &lt;- c( mean(myMat[,1]), mean(myMat[,2]), mean(myMat[,3]), mean(myMat[,4]) ) myMean #&gt; [1] 10.08 10.19 10.54 9.56 for를 사용하면 이렇게 됩니다. myMean &lt;- c() for(i in 1:4){ myMean&lt;-c(myMean,mean(myMat[,i])) } myMean #&gt; [1] 10.08 10.19 10.54 9.56 여기서 함수화도 많이 진행하는 것 같더군요. myLoop &lt;- function(somemat) { myMean &lt;- c() for(i in 1:ncol(somemat)){ myMean&lt;-c(myMean,mean(myMat[,i])) } return(myMean) } myLoop(myMat) #&gt; [1] 10.08 10.19 10.54 9.56 근데 이제 열방향 mean 함수를 만드는게 끝났네요. 행방향을 진행하려면 똑같은걸 더 만들어야 합니다. 한 함수에 합쳐서 옵션으로 줘도 좋을 것 같군요. 한번 만들어 보세요. 하지만 apply는 이 걸 한줄에 할 수 있게 해줍니다. apply(myMat, 2, mean) #&gt; [1] 10.08 10.19 10.54 9.56 위에 결과와 비교해 보세요. 위에서 사용한 identical 함수로 두 결과를 비교해 보겠습니다. identical(myLoop(myMat),apply(myMat, 2, mean)) #&gt; [1] TRUE ?apply를 통해 중간의 숫자가 어떤 의미를 가지는지 확인해 보세요. 1은 같은 행끼리의 계산을, 2는 같은 열끼리의 계산을 의미합니다. apply는 3가지 옵션을 가지는데, 첫 번째는 데이터, 두 번째는 계산의 방향, 세 번째는 계산에 사용할 함수입니다. 함수부분은 다양한 함수를 사용할 수 있습니다. apply(myMat,2,class) #&gt; [1] &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; apply(myMat,2,sum) #&gt; [1] 40.3 40.7 42.2 38.2 apply(myMat,2,quantile) #&gt; [,1] [,2] [,3] [,4] #&gt; 0% 9.16 9.18 9.69 7.79 #&gt; 25% 9.32 10.04 10.21 8.98 #&gt; 50% 9.77 10.41 10.48 9.67 #&gt; 75% 10.54 10.55 10.81 10.25 #&gt; 100% 11.60 10.74 11.51 11.12 자주 사용하는 평균이나 합 같은 경우는 함수로도 구현되어 있습니다. rowMeans, colMeans, rowSums, colSums가 그것 입니다. 각각 apply로 어떻게 하면 되는지 생각해 보세요. apply에 적용하는 함수 안에 데이터만 들어가는 함수 이외에 다른 옵션을 지정해야 할 수 있습니다. apply는 ,를 이용해서 다음 옵션으로 사용하는 함수 안의 옵션을 작성할 수 있습니다. myMat[1,4]&lt;-NA apply(myMat,2,sum) #&gt; [1] 40.3 40.7 42.2 NA apply(myMat,2,sum, na.rm = TRUE) #&gt; [1] 40.3 40.7 42.2 28.9 apply에서 계산에 사용할 함수는 사용자가 만들어서 진행할 수도 있고, 임시로 만들 수도 있습니다. naSum &lt;- function(x){ return(sum(x,na.rm = TRUE)) } apply(myMat,2,naSum) #&gt; [1] 40.3 40.7 42.2 28.9 apply(myMat,2,function(x) sum(x,na.rm = TRUE)) #&gt; [1] 40.3 40.7 42.2 28.9 만들어야 할 함수가 복잡하지 않으면 저는 임시로 작성하는 방법을 사용하는 편입니다. 3.3.2 *apply {#applys} apply는 lapply, tapply, sapply, mapply 등의 apply-family를 가지고 있습니다. 우선 lapply부터 살펴보겠습니다. 앞에 l이 붙으면서 list 자료형에 대해 apply의 역할을 수행하는 함수라는 의미가 붙었습니다. 결과도 list로 나옵니다. (listData &lt;- list(a = 1, b = 1:3, c = 10:100) ) #&gt; $a #&gt; [1] 1 #&gt; #&gt; $b #&gt; [1] 1 2 3 #&gt; #&gt; $c #&gt; [1] 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #&gt; [18] 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #&gt; [35] 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #&gt; [52] 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #&gt; [69] 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #&gt; [86] 95 96 97 98 99 100 lapply(listData, length) #&gt; $a #&gt; [1] 1 #&gt; #&gt; $b #&gt; [1] 3 #&gt; #&gt; $c #&gt; [1] 91 lapply(listData, sum) #&gt; $a #&gt; [1] 1 #&gt; #&gt; $b #&gt; [1] 6 #&gt; #&gt; $c #&gt; [1] 5005 list 자료형은 사용하시면서 느끼시겠지만 다른 곳에 사용하기 불편한 점이 있습니다. 그래서 다시 list를 푸는 방법으로 unlist를 사용하는데요. ?unlist를 입력해서 내용을 확인해보세요. (listData &lt;- list(a = 1, b = 1:3, c = 10:100) ) #&gt; $a #&gt; [1] 1 #&gt; #&gt; $b #&gt; [1] 1 2 3 #&gt; #&gt; $c #&gt; [1] 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #&gt; [18] 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #&gt; [35] 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #&gt; [52] 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #&gt; [69] 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #&gt; [86] 95 96 97 98 99 100 unlist(lapply(listData, length)) #&gt; a b c #&gt; 1 3 91 unlist(lapply(listData, sum)) #&gt; a b c #&gt; 1 6 5005 그런데 입력을 list로 받는 것은 어쩔수 없다고 쳐도, 결과물은 위처럼 vector로 받는 것이 편한 경우가 많습니다. unlist(lapply(데이터,함수))는 sapply와 같은 동작을 합니다. (listData &lt;- list(a = 1, b = 1:3, c = 10:100) ) #&gt; $a #&gt; [1] 1 #&gt; #&gt; $b #&gt; [1] 1 2 3 #&gt; #&gt; $c #&gt; [1] 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #&gt; [18] 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #&gt; [35] 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #&gt; [52] 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #&gt; [69] 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #&gt; [86] 95 96 97 98 99 100 sapply(listData, length) #&gt; a b c #&gt; 1 3 91 sapply(listData, sum) #&gt; a b c #&gt; 1 6 5005 이외에도 list안에 list까지 계산하는 rapply, 지정한 이름으로 실행할 수 있는 tapply 등이 있습니다만, 거의 apply나 sapply만 사용한 것 같습니다. 더 궁금하신 사항은 여기를 참고해 주세요. "],
["sql.html", "4 데이터 원본/의존성의 개념과 SQL 문법 익히기 4.1 사전 준비 4.2 데이터를 바라보는 시선 4.3 기본 SQL 문법", " 4 데이터 원본/의존성의 개념과 SQL 문법 익히기 4.1 사전 준비 4.1.1 mariaDB 설치 4.1.1.1 windows 4.1.1.2 mac 4.1.1.3 docker 4.2 데이터를 바라보는 시선 4.2.1 데이터 원본 4.2.2 데이터 의존성 4.3 기본 SQL 문법 4.3.1 CRUD와 데이터베이스 4.3.2 Read 문법 4.3.3 Join "],
["tidyr.html", "5 tidy data 개념과 dplyr+tidyr로 데이터 다루기 5.1 tidy data 5.2 tidyverse", " 5 tidy data 개념과 dplyr+tidyr로 데이터 다루기 5.1 tidy data 5.2 tidyverse "],
["ggplot.html", "6 보고용 차트를 위한 ggplot2 사용하기 6.1 test", " 6 보고용 차트를 위한 ggplot2 사용하기 6.1 test "],
["knitr.html", "7 정기 보고서 자동 작성을 위해 knitr로 문서화하고 스케줄러로 자동화하기 7.1 Markdown 문법 7.2 Rmd로 문서 작성 7.3 스케줄러", " 7 정기 보고서 자동 작성을 위해 knitr로 문서화하고 스케줄러로 자동화하기 7.1 Markdown 문법 7.2 Rmd로 문서 작성 7.3 스케줄러 "],
["shiny.html", "8 shiny 패키지를 활용한 인터렉티프 웹 만들기", " 8 shiny 패키지를 활용한 인터렉티프 웹 만들기 "],
["eba788ecb998eba9b0.html", "마치며", " 마치며 "]
]
